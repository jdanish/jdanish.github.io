{"version":3,"sources":["node_modules/@ursys/addons/_dist/addons-client-cjs.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"public/scripts/ursys-addons.js","sourcesContent":["\nrequire.register(\"@ursys/addons/_dist/addons-client-cjs.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"@ursys/addons\");\n  (function() {\n    var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// _ur_addons/@addons-client.ts\nvar addons_client_exports = {};\n__export(addons_client_exports, {\n  AddonClientTest: () => AddonClientTest,\n  CLASS: () => CLASS2,\n  COMMENT: () => ac_comment_exports\n});\nmodule.exports = __toCommonJS(addons_client_exports);\n\n// _ur/_dist/client-esm.js\nvar client_esm_exports = {};\n__export(client_esm_exports, {\n  CLASS: () => CLASS,\n  ClientTest: () => ClientTest,\n  ConsoleStyler: () => makeStyleFormatter,\n  PROMPTS: () => export_PROMPTS,\n  StateMgr: () => class_state_mgr_default,\n  TEXT: () => export_TEXT\n});\nvar __create = Object.create;\nvar __defProp2 = Object.defineProperty;\nvar __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames2 = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp2 = Object.prototype.hasOwnProperty;\nvar __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps2 = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames2(from))\n      if (!__hasOwnProp2.call(to, key) && key !== except)\n        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps2(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __publicField2 = (obj, key, value) => {\n  __defNormalProp2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar require_declare_console = __commonJS({\n  \"_ur/common/declare-console.js\"(exports, module2) {\n    var TERM_COLORS = {\n      // TOUT = makeTerminalOut(str); TOUT('hi')\n      Reset: \"\\x1B[0m\",\n      Bright: \"\\x1B[1m\",\n      Dim: \"\\x1B[2m\",\n      Underscore: \"\\x1B[4m\",\n      Blink: \"\\x1B[5m\",\n      Reverse: \"\\x1B[7m\",\n      Hidden: \"\\x1B[8m\",\n      //\n      Black: \"\\x1B[30m\",\n      White: \"\\x1B[37m\",\n      Red: \"\\x1B[31m\",\n      Orange: \"\\x1B[38;5;202m\",\n      Yellow: \"\\x1B[33m\",\n      Green: \"\\x1B[32m\",\n      Cyan: \"\\x1B[36m\",\n      Blue: \"\\x1B[34m\",\n      Purple: \"\\x1B[35m\",\n      //\n      BgBlack: \"\\x1B[40m\",\n      BgGray: \"\\x1B[100m\",\n      BgWhite: \"\\x1B[47m\",\n      BgRed: \"\\x1B[41m\",\n      BgOrange: \"\\x1B[48;5;202m\",\n      BgYellow: \"\\x1B[43m\",\n      BgCyan: \"\\x1B[46m\",\n      BgGreen: \"\\x1B[42m\",\n      BgBlue: \"\\x1B[44m\",\n      BgPurple: \"\\x1B[45m\",\n      BgPink: \"\\x1B[105m\",\n      // FORMATS\n      TagBlack: \"\\x1B[30;1m\",\n      TagWhite: \"\\x1B[37;1m\",\n      TagRed: \"\\x1B[41;37m\",\n      TagOrange: \"\\x1B[43;37m\",\n      TagYellow: \"\\x1B[43;30m\",\n      TagGreen: \"\\x1B[42;30m\",\n      TagCyan: \"\\x1B[46;37m\",\n      TagBlue: \"\\x1B[44;37m\",\n      TagPurple: \"\\x1B[45;37m\",\n      TagPink: \"\\x1B[105;1m\",\n      TagGray: \"\\x1B[100;37m\",\n      TagNull: \"\\x1B[2;37m\"\n    };\n    var CSS_COMMON = \"padding:3px 5px;border-radius:2px;\";\n    var CSS_COLORS = {\n      Reset: \"color:auto;background-color:auto\",\n      // COLOR FOREGROUND\n      Black: \"color:black\",\n      White: \"color:white\",\n      Red: \"color:red\",\n      Orange: \"color:orange\",\n      Yellow: \"color:orange\",\n      Green: \"color:green\",\n      Cyan: \"color:cyan\",\n      Blue: \"color:blue\",\n      Magenta: \"color:magenta\",\n      Pink: \"color:pink\",\n      // COLOR BACKGROUND\n      TagRed: `color:#000;background-color:#f66;${CSS_COMMON}`,\n      TagOrange: `color:#000;background-color:#fa4;${CSS_COMMON}`,\n      TagYellow: `color:#000;background-color:#fd4;${CSS_COMMON}`,\n      TagGreen: `color:#000;background-color:#5c8;${CSS_COMMON}`,\n      TagCyan: `color:#000;background-color:#2dd;${CSS_COMMON}`,\n      TagBlue: `color:#000;background-color:#2bf;${CSS_COMMON}`,\n      TagPurple: `color:#000;background-color:#b6f;${CSS_COMMON}`,\n      TagPink: `color:#000;background-color:#f9f;${CSS_COMMON}`,\n      TagGray: `color:#fff;background-color:#999;${CSS_COMMON}`,\n      TagNull: `color:#999;border:1px solid #ddd;${CSS_COMMON}`,\n      // COLOR BACKGROUND DARK (BROWSER ONLY)\n      TagDkRed: `color:white;background-color:maroon;${CSS_COMMON}`,\n      TagDkOrange: `color:white;background-color:burntorange;${CSS_COMMON}`,\n      TagDkYellow: `color:white;background-color:brown;${CSS_COMMON}`,\n      TagDkGreen: `color:white;background-color:forestgreen;${CSS_COMMON}`,\n      TagDkCyan: `color:white;background-color:cerulean;${CSS_COMMON}`,\n      TagDkBlue: `color:white;background-color:darkblue;${CSS_COMMON}`,\n      TagDkPurple: `color:white;background-color:indigo;${CSS_COMMON}`,\n      TagDkPink: `color:white;background-color:fuchsia;${CSS_COMMON}`\n    };\n    TERM_COLORS.TagBuild = TERM_COLORS.TagGray;\n    TERM_COLORS.TagError = TERM_COLORS.TagRed;\n    TERM_COLORS.TagAlert = TERM_COLORS.TagOrange;\n    TERM_COLORS.TagTest = TERM_COLORS.TagRed;\n    TERM_COLORS.TagSystem = TERM_COLORS.TagGray;\n    TERM_COLORS.TagServer = TERM_COLORS.TagGray;\n    TERM_COLORS.TagDatabase = TERM_COLORS.TagCyan;\n    TERM_COLORS.TagNetwork = TERM_COLORS.TagCyan;\n    TERM_COLORS.TagUR = TERM_COLORS.TagBlue;\n    TERM_COLORS.TagURNET = TERM_COLORS.TagBlue;\n    TERM_COLORS.TagURMOD = TERM_COLORS.TagBlue;\n    TERM_COLORS.TagAppMain = TERM_COLORS.TagGreen;\n    TERM_COLORS.TagAppModule = TERM_COLORS.TagGreen;\n    TERM_COLORS.TagAppState = TERM_COLORS.TagGreen;\n    TERM_COLORS.TagAppCore = TERM_COLORS.TagGreen;\n    TERM_COLORS.TagDataCore = TERM_COLORS.TagGreen;\n    TERM_COLORS.TagUI = TERM_COLORS.TagPurple;\n    TERM_COLORS.TagPhase = TERM_COLORS.TagPink;\n    TERM_COLORS.TagEvent = TERM_COLORS.TagPink;\n    TERM_COLORS.TagStream = TERM_COLORS.TagPink;\n    CSS_COLORS.TagDebug = `color:#fff;background-color:IndianRed;${CSS_COMMON}`;\n    CSS_COLORS.TagWarning = `color:#fff;background:linear-gradient(\n  -45deg,\n  rgb(29,161,242),\n  rgb(184,107,107),\n  rgb(76,158,135)\n);${CSS_COMMON}`;\n    CSS_COLORS.TagTest = CSS_COLORS.TagRed;\n    CSS_COLORS.TagSystem = CSS_COLORS.TagGray;\n    CSS_COLORS.TagServer = CSS_COLORS.TagGray;\n    CSS_COLORS.TagDatabase = CSS_COLORS.TagCyan;\n    CSS_COLORS.TagNetwork = CSS_COLORS.TagCyan;\n    CSS_COLORS.TagUR = `color:CornflowerBlue;border:1px solid CornflowerBlue;${CSS_COMMON}`;\n    CSS_COLORS.TagURNET = `color:#fff;background-color:MediumSlateBlue;${CSS_COMMON}`;\n    CSS_COLORS.TagURMOD = `color:#fff;background:linear-gradient(\n  -45deg,\n  CornflowerBlue 0%,\n  LightSkyBlue 25%,\n  RoyalBlue 100%\n);${CSS_COMMON}`;\n    CSS_COLORS.TagAppMain = CSS_COLORS.TagGreen;\n    CSS_COLORS.TagAppModule = CSS_COLORS.TagGreen;\n    CSS_COLORS.TagAppState = `color:#fff;background-color:Navy;${CSS_COMMON}`;\n    CSS_COLORS.TagUI = CSS_COLORS.TagDkOrange;\n    CSS_COLORS.TagEvent = CSS_COLORS.TagDkOrange;\n    CSS_COLORS.TagStream = CSS_COLORS.TagDkOrange;\n    CSS_COLORS.TagPhase = `color:#fff;background-color:MediumVioletRed;${CSS_COMMON}`;\n    module2.exports = {\n      TERM_COLORS,\n      CSS_COLORS\n    };\n  }\n});\nvar require_util_prompts = __commonJS({\n  \"_ur/common/util-prompts.js\"(exports, module2) {\n    var IS_NODE = typeof window === \"undefined\";\n    var IS_MOBILE = !IS_NODE && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n      navigator.userAgent\n    );\n    var D_CONSOLE = require_declare_console();\n    var { TERM_COLORS, CSS_COLORS } = D_CONSOLE;\n    var DEFAULT_PADDING = IS_NODE ? 10 : 8;\n    var DEFAULT_SPACE = IS_NODE ? \" \".padStart(DEFAULT_PADDING, \" \") : \" \".padStart(DEFAULT_PADDING + 4, \" \");\n    var DEFAULT_COLOR = \"TagNull\";\n    var HTCONSOLES = {};\n    var SHOW = true;\n    var PROMPT_DICT = {\n      // URSYS-RELATED MODULES\n      \"UR\": [SHOW, \"TagRed\"],\n      // SERVERS\n      \"APPSRV\": [SHOW, \"Yellow\"],\n      \"GEMSRV\": [SHOW, \"Yellow\"],\n      // SPECIAL\n      \"-\": [SHOW, \"TagNull\"]\n    };\n    function padString(str, padding = DEFAULT_PADDING) {\n      let len = str.length;\n      const nbsp = String.fromCharCode(160);\n      if (IS_NODE)\n        return `${str.padEnd(padding, \" \")}`;\n      if (padding === 0)\n        return `${str}`;\n      if (len >= padding)\n        str = str.substr(0, padding);\n      else\n        str = str.padEnd(padding, nbsp);\n      return `${str}`;\n    }\n    function m_SetPromptColors(match, color = DEFAULT_COLOR) {\n      if (typeof match !== \"string\")\n        throw Error(\"match prompt must be string\");\n      match = match.trim();\n      if (match === \"\")\n        throw Error(\"match prompt cannot be empty\");\n      let colorTable = IS_NODE ? TERM_COLORS : CSS_COLORS;\n      let validColor = false;\n      validColor = colorTable[color] !== void 0;\n      if (!validColor)\n        colorTable = IS_NODE ? CSS_COLORS : TERM_COLORS;\n      validColor = colorTable[color] !== void 0;\n      if (!validColor)\n        throw Error(`prompt color ${color} is not defined in either table`);\n      PROMPT_DICT[match] = [true, color];\n      return colorTable;\n    }\n    function m_GetEnvColor(prompt, tagColor) {\n      const colorTable = m_SetPromptColors(prompt, tagColor);\n      const [dbg_mode, defcol] = PROMPT_DICT[prompt.trim()] || [SHOW, DEFAULT_COLOR];\n      const ucolor = colorTable[tagColor];\n      const dcolor = colorTable[defcol];\n      const color = ucolor || dcolor;\n      const reset = colorTable.Reset;\n      return [dbg_mode, color, reset];\n    }\n    function m_MakeColorArray(prompt, colorName) {\n      const [dbg, color, reset] = m_GetEnvColor(prompt, colorName);\n      if (!(dbg || IS_NODE))\n        return [];\n      return IS_NODE ? [`${color}${padString(prompt)}${reset}   `] : [`%c${padString(prompt)}%c `, color, reset];\n    }\n    function m_MakeColorPromptFunction(prompt, colorName, opt = {}) {\n      const textColor = opt.color || \"Reset\";\n      const dim = opt.dim || false;\n      return IS_NODE ? (str, ...args) => {\n        if (args === void 0)\n          args = \"\";\n        let TAG = TERM_COLORS[colorName];\n        let TEXT2 = TERM_COLORS[textColor];\n        let RST = TERM_COLORS.Reset;\n        let PR22 = padString(prompt);\n        if (dim)\n          TEXT2 += TERM_COLORS.Dim;\n        console.log(`${RST}${TAG}${PR22}${RST}${TEXT2}    ${str}`, ...args);\n      } : (str, ...args) => {\n        if (args === void 0)\n          args = \"\";\n        let TEXT2 = TERM_COLORS[textColor];\n        let RST = CSS_COLORS.Reset;\n        let PR22 = padString(prompt);\n        console.log(`%c${PR22}%c%c ${str}`, RST, TEXT2, ...args);\n      };\n    }\n    function m_GetDivText(id) {\n      const el = document.getElementById(id);\n      if (!el) {\n        console.log(`GetDivText: element ${id} does not exist`);\n        return void 0;\n      }\n      const text = el.textContent;\n      if (text === void 0) {\n        console.log(`HTMLTextOut: element ${id} does not have textContent`);\n        return {};\n      }\n      el.style.whiteSpace = \"pre\";\n      el.style.fontFamily = \"monospace\";\n      return { element: el, text };\n    }\n    function m_HTMLTextJumpRow(row, lineBuffer, id) {\n      const { element, text } = m_GetDivText(id);\n      if (text === void 0)\n        return lineBuffer;\n      if (lineBuffer.length === 0) {\n        console.log(`initializing linebuffer from element id='${id}'`);\n        lineBuffer = text.split(\"\\n\");\n      }\n      if (row > lineBuffer.length - 1) {\n        const count = row + 1 - lineBuffer.length;\n        for (let i = count; i > 0; i--)\n          lineBuffer.push(\"\");\n      }\n      return lineBuffer;\n    }\n    function m_HTMLTextPrint(str = \"\", lineBuffer, id) {\n      const { element, text } = m_GetDivText(id);\n      if (!text)\n        return lineBuffer;\n      lineBuffer.push(str);\n      element.textContent = lineBuffer.join(\"\\n\");\n      return lineBuffer;\n    }\n    function m_HTMLTextPlot(str = \"\", lineBuffer, id, row = 0, col = 0) {\n      const { element, text } = m_GetDivText(id);\n      if (!element)\n        return lineBuffer;\n      if (text === void 0) {\n        console.log(`HTMLTextOut: element ${id} does not have textContent`);\n        return lineBuffer;\n      }\n      lineBuffer = m_HTMLTextJumpRow(row, lineBuffer, id);\n      let line = lineBuffer[row];\n      if (line === void 0) {\n        console.log(`HTMLTextOut: unexpected line error for line ${row}`);\n        return lineBuffer;\n      }\n      if (col + str.length > line.length + str.length) {\n        for (let i = 0; i < col + str.length - line.length; i++)\n          line += \" \";\n      }\n      let p1 = line.substr(0, col);\n      let p3 = line.substr(col + str.length, line.length - (col + str.length));\n      lineBuffer[row] = `${p1}${str}${p3}`;\n      element.textContent = lineBuffer.join(\"\\n\");\n      return lineBuffer;\n    }\n    function makeStyleFormatter2(prompt, tagColor) {\n      if (prompt.startsWith(\"UR\") && tagColor === void 0)\n        tagColor = \"TagUR\";\n      let outArray = m_MakeColorArray(prompt, tagColor);\n      if (outArray.length === 0)\n        return () => [];\n      if (IS_MOBILE)\n        outArray = [`${prompt}:`];\n      const f = (str, ...args) => [...outArray, str, ...args];\n      f._ = `\n${DEFAULT_SPACE}`;\n      return f;\n    }\n    function makeErrorFormatter(pr = \"\") {\n      const bg = \"rgba(255,0,0,1)\";\n      const bga = \"rgba(255,0,0,0.15)\";\n      pr = `ERROR ${pr}`.trim();\n      return (str, ...args) => [\n        `%c${pr}%c${str}`,\n        `color:#fff;background-color:${bg};padding:3px 7px 3px 10px;border-radius:10px 0 0 10px;`,\n        `color:${bg};background-color:${bga};padding:3px 5px;`,\n        ...args\n      ];\n    }\n    function makeWarningFormatter(pr = \"\") {\n      const bg = \"rgba(255,150,0,1)\";\n      const bga = \"rgba(255,150,0,0.15)\";\n      pr = `WARN ${pr}`.trim();\n      return (str, ...args) => [\n        `%c${pr}%c${str}`,\n        `color:#fff;background-color:${bg};padding:3px 7px 3px 10px;border-radius:10px 0 0 10px;`,\n        `color:${bg};background-color:${bga};padding:3px 5px;`,\n        ...args\n      ];\n    }\n    function dbgPrint(pr, bg = \"MediumVioletRed\") {\n      return [\n        `%c${pr}%c`,\n        `color:#fff;background-color:${bg};padding:3px 10px;border-radius:10px;`,\n        \"color:auto;background-color:auto\"\n      ];\n    }\n    function colorTagString(str, tagColor) {\n      return m_MakeColorArray(str, tagColor);\n    }\n    function makeTerminalOut(prompt, tagColor = DEFAULT_COLOR) {\n      const wrap = m_MakeColorPromptFunction(prompt, tagColor);\n      wrap.warn = m_MakeColorPromptFunction(prompt, \"TagYellow\", { color: \"Yellow\" });\n      wrap.error = m_MakeColorPromptFunction(prompt, \"TagRed\", { color: \"Red\" });\n      wrap.fail = m_MakeColorPromptFunction(prompt, \"Red\", { color: \"Red\" });\n      wrap.pass = m_MakeColorPromptFunction(prompt, \"Green\", { color: \"Green\" });\n      wrap.info = m_MakeColorPromptFunction(prompt, \"TagGray\", { dim: true });\n      wrap.DIM = \"\\x1B[2m\";\n      wrap.BRI = \"\\x1B[1m\";\n      wrap.RST = \"\\x1B[0m\";\n      return wrap;\n    }\n    function makeHTMLConsole(divId, row = 0, col = 0) {\n      const ERP = makeStyleFormatter2(\"makeHTMLConsole\", \"Red\");\n      let buffer = [];\n      if (typeof divId !== \"string\")\n        throw Error(\"bad id\");\n      if (!document.getElementById(divId)) {\n        console.warn(...ERP(`id '${divId}' doesn't exist`));\n        return {\n          print: () => {\n          },\n          plot: () => {\n          },\n          clear: () => {\n          },\n          gotoRow: () => {\n          }\n        };\n      }\n      let hcon;\n      if (HTCONSOLES[divId]) {\n        hcon = HTCONSOLES[divId];\n      } else {\n        hcon = {\n          buffer: [],\n          plot: (str, y = row, x = col) => {\n            buffer = m_HTMLTextPlot(str, buffer, divId, y, x);\n          },\n          print: (str) => {\n            buffer = m_HTMLTextPrint(str, buffer, divId);\n          },\n          clear: (startRow = 0, endRow = buffer.length) => {\n            buffer.splice(startRow, endRow);\n          },\n          gotoRow: (row2) => {\n            buffer = m_HTMLTextJumpRow(row2, buffer, divId);\n          }\n        };\n        HTCONSOLES[divId] = hcon;\n      }\n      return hcon;\n    }\n    function printTagColors() {\n      const colortable = IS_NODE ? TERM_COLORS : CSS_COLORS;\n      const colors = Object.keys(colortable).filter((element) => element.includes(\"Tag\"));\n      const reset = colortable.Reset;\n      const out = \"dbg_colors\";\n      if (!IS_NODE)\n        console.groupCollapsed(out);\n      colors.forEach((key) => {\n        const color = colortable[key];\n        const items = IS_NODE ? [`${padString(out)} - (node) ${color}${key}${reset}`] : [`(browser) %c${key}%c`, color, reset];\n        console.log(...items);\n      });\n      if (!IS_NODE)\n        console.groupEnd();\n    }\n    module2.exports = {\n      TERM: TERM_COLORS,\n      CSS: CSS_COLORS,\n      padString,\n      makeStyleFormatter: makeStyleFormatter2,\n      makeErrorFormatter,\n      makeWarningFormatter,\n      dbgPrint,\n      makeTerminalOut,\n      makeHTMLConsole,\n      printTagColors,\n      colorTagString\n    };\n  }\n});\nvar require_util_text = __commonJS({\n  \"_ur/common/util-text.js\"(exports, module2) {\n    function PreprocessDataText(str) {\n      let normalizedStr = str.replace(/\\r\\n|\\r/g, \"\\n\");\n      normalizedStr = normalizedStr.split(\"\\n\").map((line) => line.replace(/\\s+$/, \"\")).map((line) => line.replace(/^\\s+/, \"\")).join(\"\\n\");\n      normalizedStr = normalizedStr.replace(/\\t/g, \"  \");\n      let lines = normalizedStr.split(\"\\n\");\n      const processDelimited = (line, delimiter) => {\n        let parts = line.split(delimiter);\n        for (let i = 0; i < parts.length; i++) {\n          parts[i] = parts[i].trim();\n          parts[i] = parts[i].replace(/\\s+/g, \" \");\n        }\n        return parts.join(delimiter);\n      };\n      for (let i = 0; i < lines.length; i++) {\n        lines[i] = processDelimited(lines[i], \",\", { preserve: true });\n        lines[i] = processDelimited(lines[i], \":\", { preserve: true });\n      }\n      normalizedStr = lines.join(\"\\n\").trim();\n      return normalizedStr + \"\\n\";\n    }\n    module2.exports = {\n      PreprocessDataText\n    };\n  }\n});\nvar import_util_prompts = __toESM(require_util_prompts());\nvar import_util_text = __toESM(require_util_text());\nvar OPSEQS = /* @__PURE__ */ new Map();\nfunction m_ValidateSeqName(sn) {\n  const fn = \"m_ValidateSeqName\";\n  const pcErr = \"name must be PascalCase string\";\n  if (sn === \"\")\n    throw Error(`${fn}: ${pcErr}`);\n  if (sn === void 0)\n    throw Error(`${fn}: ${pcErr}`);\n  if (typeof sn !== \"string\")\n    throw Error(`${fn}: ${pcErr}`);\n  if (sn !== sn[0].toUpperCase() + sn.slice(1))\n    throw Error(`${fn}: ${pcErr}`);\n  if (sn.trim() !== sn)\n    throw Error(`${fn}: name must not have leading/trailing spaces`);\n}\nfunction m_ValidateActiveSeq(seq) {\n  if (seq instanceof OpSequencer) {\n    if (seq._disposed)\n      throw Error(`sequencer ${seq.seqName} is disposed`);\n    else\n      return;\n  }\n  throw Error(\"not a sequence instance or undefined\");\n}\nfunction m_ValidateNodeName(nn) {\n  const fn = \"m_ValidateNodeName\";\n  if (nn === \"\")\n    throw Error(`${fn}: name must be lc string`);\n  if (nn === void 0)\n    throw Error(`${fn}: name must be lc string`);\n  if (typeof nn !== \"string\")\n    throw Error(`${fn}: name must be lc string`);\n  if (nn !== nn.toLowerCase())\n    throw Error(`${fn}: name must be lc`);\n  if (nn.trim() !== nn)\n    throw Error(`${fn}: name must not have leading/trailing spaces`);\n}\nvar OpSequencer = class _OpSequencer {\n  // true if disposed\n  constructor(seqName) {\n    __publicField2(this, \"ops\");\n    __publicField2(this, \"seqName\");\n    __publicField2(this, \"lastOp\");\n    __publicField2(this, \"currentOp\");\n    __publicField2(this, \"opIndex\");\n    __publicField2(this, \"opsMap\");\n    __publicField2(this, \"subs\");\n    __publicField2(this, \"_disposed\");\n    m_ValidateSeqName(seqName);\n    seqName = seqName.trim().toUpperCase();\n    if (OPSEQS.has(seqName)) {\n      console.warn(\n        `(not an error) '${seqName}' construction duplicate, returning existing instance`\n      );\n      return OPSEQS.get(seqName);\n    }\n    this.seqName = seqName;\n    this.ops = [];\n    this.opsMap = /* @__PURE__ */ new Map();\n    this.opIndex = -1;\n    this.currentOp = null;\n    this.lastOp = null;\n    this.subs = /* @__PURE__ */ new Map();\n    this._disposed = false;\n    OPSEQS.set(seqName, this);\n  }\n  /* --- add nodes --- */\n  /** given nodeName and a source TOpNode, add a clone of the source node to the sequencer */\n  addOp(name, data, opt) {\n    const fn = \"addOp\";\n    if (data === void 0)\n      throw Error(`${fn}: arg2 must be TOpNode`);\n    if (typeof name !== \"string\")\n      throw Error(`${fn}: arg1 must be name:string`);\n    if (typeof data._name === \"string\")\n      throw Error(`${fn}: node ${name} reused`);\n    if (data._index !== void 0)\n      throw Error(`${fn}: node ${name} reused`);\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(name);\n    if (this.opIndex !== -1)\n      throw Error(`${fn}: sequencer already started`);\n    if (this.hasOp(name))\n      throw Error(`${fn}: node '${name}' already exists`);\n    const index = this.ops.length;\n    this.opsMap.set(name, index);\n    const newData = { ...data };\n    if (opt == null ? void 0 : opt.mutable)\n      Object.freeze(newData);\n    const newNode = {\n      _opIndex: index,\n      _seqName: this.seqName,\n      _opName: name,\n      data: newData\n    };\n    this.ops.push(newNode);\n    return newNode;\n  }\n  deleteOp(name) {\n    const fn = \"deleteOp\";\n    console.error(`${fn}: not implemented by design`);\n  }\n  /* --- access operations --- */\n  data(key) {\n    m_ValidateActiveSeq(this);\n    if (typeof key === \"string\")\n      return this.currentOp.data[key];\n    return this.currentOp.data;\n  }\n  length() {\n    m_ValidateActiveSeq(this);\n    return this.ops.length;\n  }\n  /* --- sequencer operations --- */\n  start() {\n    const fn = \"start\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex !== -1)\n      throw Error(`${fn}: sequencer already started`);\n    if (this.ops.length === 0)\n      throw Error(`${fn}: no operations to run`);\n    this.opIndex = 0;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  current() {\n    const fn = \"current\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === -1)\n      throw Error(`${fn}: sequencer not started`);\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  stop() {\n    const fn = \"stop\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === -1)\n      throw Error(\"stop: sequencer not started\");\n    this.opIndex = -1;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  next() {\n    const fn = \"next\";\n    if (this.opIndex === -1)\n      return this.start();\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === this.ops.length - 1)\n      return void 0;\n    ++this.opIndex;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  previous() {\n    const fn = \"previous\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === -1)\n      throw Error(`${fn}: sequencer not started`);\n    if (this.opIndex === 0)\n      return void 0;\n    --this.opIndex;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  /* --- node events --- */\n  subscribe(opName, subf) {\n    const fn = \"onEnter\";\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(opName);\n    if (!this.hasOp(opName))\n      throw Error(`${fn}: node '${opName}' does not exist`);\n    if (!this.subs.has(opName))\n      this.subs.set(opName, /* @__PURE__ */ new Set());\n    this.subs.get(opName).add(subf);\n  }\n  unsubscribe(name, subf) {\n    const fn = \"onEnter\";\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(name);\n    if (!this.hasOp(name))\n      throw Error(`${fn}: node '${name}' does not exist`);\n    const subs = this.subs.get(name);\n    if (subs.has(subf))\n      subs.delete(subf);\n  }\n  _update() {\n    const fn = \"_update\";\n    m_ValidateActiveSeq(this);\n    this.lastOp = this.currentOp;\n    this.currentOp = this.ops[this.opIndex];\n  }\n  _notifyChange() {\n    const fn = \"_notifyChange\";\n    m_ValidateActiveSeq(this);\n    const subs = this.subs.get(this.currentOp._opName);\n    if (subs)\n      subs.forEach((subf) => subf(this.currentOp, this.lastOp, this));\n  }\n  /* --- node utilities --- */\n  hasOp(opName) {\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(opName);\n    return this.ops.some((op) => op._opName === opName);\n  }\n  matchOp(opName) {\n    const fn = \"matchOp\";\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(opName);\n    if (!this.hasOp(opName))\n      throw Error(`${fn}: node '${opName}' does not exist`);\n    return opName === this.ops[this.opIndex]._opName;\n  }\n  /** remove all nodes and subscribers */\n  dispose() {\n    _OpSequencer.DeleteSequencer(this.seqName);\n  }\n  /* --- static utilities --- */\n  static GetSequencer(seqName) {\n    m_ValidateSeqName(seqName);\n    return OPSEQS.get(seqName);\n  }\n  static DeleteSequencer(seqName) {\n    const seq = _OpSequencer.GetSequencer(seqName);\n    seq.opsMap.clear();\n    seq.subs.forEach((subs) => subs.clear());\n    seq.ops.length = 0;\n    seq._disposed = true;\n    OPSEQS.delete(seqName);\n  }\n};\nvar class_op_seq_default = OpSequencer;\nvar VM_STATE = {};\nvar GROUPS = /* @__PURE__ */ new Map();\nvar USED_PROPS = /* @__PURE__ */ new Map();\nvar StateMgr = class _StateMgr {\n  // queued side effects\n  /// CONSTRUCTOR /////////////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  constructor(groupName) {\n    __publicField2(this, \"name\");\n    __publicField2(this, \"init\");\n    __publicField2(this, \"subs\");\n    __publicField2(this, \"queue\");\n    __publicField2(this, \"taps\");\n    __publicField2(this, \"effects\");\n    if (typeof groupName !== \"string\")\n      throw Error(\"groupName must be a string\");\n    groupName = groupName.trim().toUpperCase();\n    if (GROUPS.has(groupName)) {\n      console.warn(\n        `(not an error) '${groupName}' construction duplicate, returning existing instance`\n      );\n      return GROUPS.get(groupName);\n    }\n    this.name = groupName;\n    this.init = false;\n    this.subs = /* @__PURE__ */ new Set();\n    this.queue = [];\n    this.taps = [];\n    this.effects = [];\n    VM_STATE[this.name] = {};\n    this.state = this.state.bind(this);\n    this.sendState = this.sendState.bind(this);\n    this.subscribeState = this.subscribeState.bind(this);\n    this.unsubscribeState = this.unsubscribeState.bind(this);\n    this.queueEffect = this.queueEffect.bind(this);\n    this._initializeState = this._initializeState.bind(this);\n    this._setState = this._setState.bind(this);\n    this._insertStateEvent = this._insertStateEvent.bind(this);\n    this._interceptState = this._interceptState.bind(this);\n    this._isValidState = this._isValidState.bind(this);\n    this._mergeState = this._mergeState.bind(this);\n    this._notifySubs = this._notifySubs.bind(this);\n    this._enqueue = this._enqueue.bind(this);\n    this._dequeue = this._dequeue.bind(this);\n    this._doEffect = this._doEffect.bind(this);\n    GROUPS.set(this.name, this);\n  }\n  /// MAIN CLASS METHODS //////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** Return a COPY of the current clonedEvent */\n  state(key) {\n    const state = this._derefProps({ ...VM_STATE[this.name] });\n    if (typeof key === \"string\" && key.length > 0)\n      return state[key];\n    return state;\n  }\n  /** Handle a clonedEvent update from a subscribing module. The incoming\n   *  vmstateEvent is checked against the master state object to ensure it\n   *  contains valid keys. Any filter functions are allowed to mutate a copy of\n   *  the incoming state event.\n   *  @param {object} vmStateEvent - object with group-specific props\n   */\n  sendState(vmStateEvent, callback) {\n    if (this._isValidState(vmStateEvent)) {\n      const clonedEvent = this._cloneStateObject(vmStateEvent);\n      this.taps.forEach((tap) => tap(clonedEvent));\n      const action = { stateEvent: clonedEvent, callback };\n      this._enqueue(action);\n    } else\n      throw Error(\"SendState: invalid vmState update received, got:\");\n  }\n  /** Subscribe to state. The subscriber function looks like:\n   *  ( vmStateEvent, currentState ) => void\n   */\n  subscribeState(subFunc) {\n    if (typeof subFunc !== \"function\")\n      throw Error(\"subscriber must be function\");\n    if (this.subs.has(subFunc))\n      console.warn(\"duplicate subscriber function\");\n    this.subs.add(subFunc);\n  }\n  /** Unsubscribe state */\n  unsubscribeState(subFunc) {\n    if (!this.subs.delete(subFunc))\n      console.warn(\"function not subscribed for\", this.name);\n  }\n  /** When executing a side effect from a component, use this method to\n   *  hold it until after all state updates have completed, so the DOM\n   *  is stable\n   */\n  queueEffect(effectFunc) {\n    if (typeof effectFunc !== \"function\")\n      throw Error(\"effect must be a function\");\n    this.effects.push(effectFunc);\n    this._doEffect();\n  }\n  /// CLASS HELPER METHODS ////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** Set the state object directly. used to initialize the state from within\n   *  an appcore module. skips state validation because the VM_STATE entry\n   *  is an empty object\n   */\n  _initializeState(stateObj) {\n    if (this.init)\n      throw Error(`_initializeState: store '${this.name}' already initialized`);\n    Object.keys(stateObj).forEach((k) => {\n      if (k.toLowerCase() !== k)\n        throw Error(`_initializeState: props must be lowercase, not '${k}'`);\n      if (stateObj[k] === void 0)\n        throw Error(\n          `_initializeState: prop '${k}' value can't be undefined (use null instead)`\n        );\n    });\n    if (VM_STATE[this.name]) {\n      Object.keys(stateObj).forEach((k) => {\n        if (k === \"_group\")\n          return;\n        const assTo = USED_PROPS.get(k);\n        if (assTo !== void 0)\n          throw Error(`${k} already assigned to ${assTo}`);\n        USED_PROPS.set(k, this.name);\n      });\n      VM_STATE[this.name] = stateObj;\n      this.init = true;\n    } else\n      throw Error(`${this.name} does't exist in VM_STATE`);\n  }\n  /** In some cases, we want to update state but not trigger subscribers\n   *  related to it. Alias for _mergeState()\n   */\n  _setState(vmState) {\n    this._mergeState(vmState);\n  }\n  /** When SendState() is invoked, give the instance manager a change to\n   *  inspect the incoming state and do a side-effect and/or a filter.\n   *  They will run in order of interceptor registration\n   *  @param {function} tapFunc - receive stateEvent to mutate or act-on\n   */\n  _interceptState(tapFunc) {\n    if (typeof tapFunc !== \"function\")\n      throw Error(`'${tapFunc}' is not a function`);\n    this.taps.push(tapFunc);\n  }\n  /** Allow synthesis of a state event by adding to queue without\n   *  immediately executing it. For use by _interceptState only.\n   *  Creates an action { stateObj, callback }\n   */\n  _insertStateEvent(stateEvent, callback) {\n    this._enqueue({ stateEvent, callback });\n  }\n  /** Return true if the event object conforms to expectations (see below) */\n  _isValidState(stateObj) {\n    const curState = VM_STATE[this.name];\n    let keysOk = true;\n    Object.keys(stateObj).forEach((k) => {\n      const keyTest = keysOk && curState[k] !== void 0;\n      if (keyTest === false)\n        console.warn(`isValidState: '${k}' not a valid key`);\n      keysOk = keysOk && keyTest;\n    });\n    return keysOk;\n  }\n  /** Scan the object properties for arrays, and mutate with a new array.\n   *  In the case of an array containing references, the references will still\n   *  be the same but the array itself will be different\n   */\n  _derefProps(stateObj) {\n    Object.keys(stateObj).forEach((k) => {\n      if (Array.isArray(stateObj[k]))\n        stateObj[k] = [...stateObj[k]];\n    });\n    return stateObj;\n  }\n  /** Utility method to clone state event. It handles array cloning as well but\n   *  is otherwise a shallow clone\n   */\n  _cloneStateObject(stateObj) {\n    const clone = this._derefProps({ ...stateObj });\n    return clone;\n  }\n  /** Take a clonedEvent event object and update the VM_STATE entry with\n   *  its property values. This creates an entirely new state object\n   */\n  _mergeState(stateObj) {\n    if (!this._isValidState(stateObj))\n      return void 0;\n    const newState = this._derefProps({\n      ...VM_STATE[this.name],\n      ...stateObj\n    });\n    VM_STATE[this.name] = newState;\n    return newState;\n  }\n  /** Forward the event to everyone. The vmStateEvent object contains\n   *  properties that changed only, appending a 'stateGroup' identifier\n   *  that tells you who sent it. Sends a read-only copy.\n   */\n  _notifySubs(stateObj) {\n    setTimeout(() => {\n      const subs = [...this.subs.values()];\n      stateObj.stateGroup = this.name;\n      const currentState = this._derefProps({ ...VM_STATE[this.name] });\n      subs.forEach((sub) => sub(stateObj, currentState));\n    });\n  }\n  /** Placeholder queueing system that doesn't do much now.\n   *  An action is { vmStateEvent, callback }\n   */\n  _enqueue(action) {\n    const { stateEvent, callback } = action;\n    if (!this._isValidState(stateEvent)) {\n      console.warn(\"bad vmStateEvent\", stateEvent);\n      return;\n    }\n    if (callback && typeof callback !== \"function\") {\n      console.warn(\"call must be function, not\", typeof callback, callback);\n      return;\n    }\n    this.queue.push(action);\n    this._dequeue();\n  }\n  /** Placeholder dequeing system that doesn't do much now.\n   *  An action is { vmStateEvent, callback }\n   */\n  _dequeue() {\n    const callbacks = [];\n    let action = this.queue.shift();\n    while (action !== void 0) {\n      const { vmStateEvent, callback } = action;\n      this._mergeState(vmStateEvent);\n      this._notifySubs(vmStateEvent);\n      if (typeof callback === \"function\")\n        callbacks.push(callback);\n      action = this.queue.shift();\n    }\n    callbacks.forEach((f) => f());\n    this._doEffect();\n  }\n  /** execute effect functions that have been queued, generally if there\n   *  are no pending state changes\n   */\n  _doEffect() {\n    if (this.queue.length > 0)\n      return;\n    setTimeout(() => {\n      let effect = this.effects.shift();\n      while (effect !== void 0) {\n        effect();\n        effect = this.effects.shift();\n      }\n    });\n  }\n  /// STATIC METHODS //////////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** Return a state manager instance if it exists, undefined if not. Throws\n   *  errors if there are issues with the name */\n  static GetStateManager(groupName) {\n    if (typeof groupName !== \"string\")\n      throw Error(`${groupName} is not a string`);\n    const bucket = groupName.trim().toUpperCase();\n    if (bucket !== groupName)\n      throw Error(`groupNames should be all uppercase, not ${bucket}`);\n    return GROUPS[bucket];\n  }\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** return a locked copy of the state of a particular named state group.\n   *  Unlike GetStateManager, this returns just the data object.\n   */\n  static GetStateData(groupName) {\n    if (typeof groupName !== \"string\")\n      throw Error(`${groupName} is not a string`);\n    const bucket = groupName.trim().toUpperCase();\n    if (bucket !== groupName)\n      throw Error(`groupNames should be all uppercase, not ${bucket}`);\n    const state = VM_STATE[bucket];\n    if (!state)\n      throw Error(`stateGroup ${bucket} is not defined`);\n    const readOnlyState = { ...state };\n    for (const prop of Object.keys(readOnlyState)) {\n      Object.defineProperty(readOnlyState, prop, {\n        writable: false\n      });\n    }\n    return readOnlyState;\n  }\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** return a Stage Manager instance. This just hides the new operator that\n   *  purposefully always returns an instance of an existing group if it\n   *  already exists\n   */\n  static GetInstance(groupName) {\n    return new _StateMgr(groupName);\n  }\n};\nvar class_state_mgr_default = StateMgr;\nvar { makeStyleFormatter } = import_util_prompts.default;\nvar PR = makeStyleFormatter(\"UR\", \"TagCyan\");\nvar CLASS = {\n  OpSequencer: class_op_seq_default,\n  StateMgr: class_state_mgr_default\n};\nfunction ClientTest() {\n  console.log(...PR(\"System Integration of new URSYS module successful!\"));\n}\nvar export_PROMPTS = import_util_prompts.default;\nvar export_TEXT = import_util_text.default;\n\n// _ur_addons/net/urnet-types.ts\nvar VALID_MSG_CHANNELS = [\"NET\", \"SRV\", \"LOCAL\", \"\"];\nvar VALID_PKT_TYPES = [\n  \"ping\",\n  \"signal\",\n  \"send\",\n  \"call\",\n  \"_auth\",\n  // special packet\n  \"_reg\",\n  // special packet\n  \"_decl\"\n  // special packet\n];\nvar VALID_ADDR_PREFIX = [\"???\", \"UR_\", \"WSS\", \"UDS\", \"MQT\", \"SRV\"];\nvar UADDR_DIGITS = 3;\nvar USED_ADDRS = /* @__PURE__ */ new Set();\nvar zeroPad = `0`.padStart(UADDR_DIGITS, \"0\");\nvar UADDR_NONE = `???${zeroPad}`;\nfunction IsValidType(msg_type) {\n  return VALID_PKT_TYPES.includes(msg_type);\n}\nfunction IsValidChannel(msg_chan) {\n  return VALID_MSG_CHANNELS.includes(msg_chan);\n}\nfunction IsValidAddress(addr) {\n  if (typeof addr !== \"string\")\n    return false;\n  let prelen = 0;\n  if (!VALID_ADDR_PREFIX.some((pre) => {\n    prelen = pre.length;\n    return addr.startsWith(pre);\n  }))\n    return false;\n  const num = parseInt(addr.slice(prelen));\n  if (isNaN(num))\n    return false;\n  return true;\n}\nfunction IsValidMessage(msg) {\n  try {\n    return DecodeMessage(msg);\n  } catch (err) {\n    console.log(err.message);\n    console.log(err.stack.split(\"\\n\").slice(1).join(\"\\n\").trim());\n    return void 0;\n  }\n}\nvar ADDR_MAX_ID = 0;\nfunction AllocateAddress(opt) {\n  const fn = \"AllocateAddress\";\n  let addr = opt == null ? void 0 : opt.addr;\n  let pre = (opt == null ? void 0 : opt.prefix) || \"UA\";\n  if (addr === void 0) {\n    let id = ++ADDR_MAX_ID;\n    let padId = `${id}`.padStart(UADDR_DIGITS, \"0\");\n    addr = `${pre}${padId}`;\n  } else if (USED_ADDRS.has(addr)) {\n    throw Error(`${fn} - address ${addr} already allocated`);\n  }\n  USED_ADDRS.add(addr);\n  return addr;\n}\nfunction DecodeMessage(msg) {\n  if (typeof msg !== \"string\")\n    throw Error(`message must be string: ${msg}`);\n  if (msg !== msg.toUpperCase())\n    throw Error(`message must be uppercase: ${msg}`);\n  const bits = msg.split(\":\");\n  if (bits.length === 0)\n    throw Error(`invalid empty message`);\n  if (bits.length > 2)\n    throw Error(`invalid channel:message format ${msg}`);\n  let [chan, name] = bits;\n  if (bits.length === 1) {\n    name = chan;\n    chan = \"LOCAL\";\n  }\n  if (chan === \"\")\n    chan = \"LOCAL\";\n  if (!IsValidChannel(chan))\n    throw Error(`prefix must be ${VALID_MSG_CHANNELS.join(\" \").trim()} not ${chan}`);\n  return [chan, name];\n}\nfunction NormalizeMessage(msg) {\n  let [chan, name] = DecodeMessage(msg);\n  if (chan === \"LOCAL\")\n    chan = \"\";\n  return `${chan}:${name}`;\n}\nfunction NormalizeData(data) {\n  if (Array.isArray(data) && data.length == 1)\n    return data[0];\n  return data;\n}\nfunction IsLocalMessage(msg) {\n  const [chan] = DecodeMessage(msg);\n  return chan === \"LOCAL\";\n}\nfunction IsNetMessage(msg) {\n  const [chan] = DecodeMessage(msg);\n  return chan === \"NET\" || chan === \"SRV\";\n}\nfunction GetPacketHashString(pkt) {\n  return `${pkt.src_addr}:${pkt.id}`;\n}\n\n// _ur_addons/net/class-urnet-packet.ts\nvar PR2 = typeof process !== \"undefined\" ? \"Packet\".padEnd(13) : \"Packet:\";\nvar LOG = (...args) => console.log(PR2, ...args);\nvar NetPacket = class {\n  // returned error message\n  constructor(msg, data) {\n    __publicField(this, \"id\");\n    // network-wide unique id for this packet\n    __publicField(this, \"msg_type\");\n    // ping, signal, send, call\n    __publicField(this, \"msg\");\n    // name of the URNET message\n    __publicField(this, \"data\");\n    // payload of the URNET message\n    __publicField(this, \"auth\");\n    // authentication token\n    __publicField(this, \"src_addr\");\n    // URNET address of the sender\n    __publicField(this, \"hop_seq\");\n    // URNET addresses that have seen this packet\n    __publicField(this, \"hop_log\");\n    // log of debug messages by hop\n    __publicField(this, \"hop_dir\");\n    // direction of the packet 'req' or 'res'\n    __publicField(this, \"hop_rsvp\");\n    // whether the packet is a response to a request\n    __publicField(this, \"err\");\n    this.id = void 0;\n    this.src_addr = void 0;\n    this.hop_rsvp = false;\n    this.hop_seq = [];\n    this.hop_log = [];\n    this.auth = void 0;\n    this.err = void 0;\n    if (data !== void 0)\n      this.data = data;\n    if (typeof msg === \"string\") {\n      if (!IsValidMessage(msg))\n        throw Error(`invalid msg format: ${msg}`);\n      this.msg = msg;\n    }\n  }\n  /** after creating a new packet, use setMeta() to assign id and envelope\n   *  meta used for routing and return packets\n   */\n  setMeta(msg_type, opt) {\n    if (!IsValidType(msg_type))\n      throw Error(`invalid msg_type: ${msg_type}`);\n    this.msg_type = msg_type;\n    this.hop_dir = (opt == null ? void 0 : opt.dir) || \"req\";\n    this.hop_rsvp = (opt == null ? void 0 : opt.rsvp) || false;\n  }\n  /** add hop to the hop sequence */\n  addHop(hop) {\n    if (!IsValidAddress(hop))\n      throw Error(`invalid hop: ${hop}`);\n    this.hop_seq.push(hop);\n  }\n  /** utility setters w/ checks - - - - - - - - - - - - - - - - - - - - - - **/\n  /** manually set the source address, with check */\n  setSrcAddr(s_addr) {\n    if (!IsValidAddress(s_addr))\n      throw Error(`invalid src_addr: ${s_addr}`);\n    if (this.hop_seq.length > 0 && this.hop_seq[0] !== s_addr)\n      throw Error(`src_addr ${s_addr} != ${this.hop_seq[0]}`);\n    this.src_addr = s_addr;\n    return this;\n  }\n  /** manually set direction */\n  setDir(dir) {\n    if (dir !== \"req\" && dir !== \"res\")\n      throw Error(`invalid dir: ${dir}`);\n    this.hop_dir = dir;\n    return this;\n  }\n  /** set the authorization token */\n  setAuth(auth) {\n    if (typeof auth !== \"string\") {\n      LOG(\"setAuth: invalid auth\", auth);\n      throw Error(`invalid auth: ${auth}`);\n    }\n    this.auth = auth;\n    return this;\n  }\n  /** set message and data */\n  setMsgData(msg, data) {\n    this.setMsg(msg);\n    this.setData(data);\n    return this;\n  }\n  /** set message */\n  setMsg(msg) {\n    this.msg = msg;\n    return this;\n  }\n  /** set data */\n  setData(data) {\n    this.data = data;\n    return this;\n  }\n  /** merge data */\n  mergeData(data) {\n    this.data = { ...this.data, ...data };\n    return this;\n  }\n  /** packet reconstruction - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** make a packet from existing JSON */\n  setFromJSON(json) {\n    if (typeof json !== \"string\")\n      throw Error(`invalid json: ${json}, is ${typeof json}`);\n    return this.deserialize(json);\n  }\n  /** make a packet from existing object */\n  setFromObject(pktObj) {\n    const fn = \"setFromObject\";\n    if (typeof pktObj !== \"object\")\n      throw Error(`invalid pktObj: ${pktObj}, is ${typeof pktObj}`);\n    this.id = pktObj.id;\n    this.msg = pktObj.msg;\n    if (pktObj.data === void 0)\n      LOG(fn, `... pktObj${pktObj.id} .data is undefined`);\n    this.data = pktObj.data;\n    this.src_addr = pktObj.src_addr;\n    this.hop_log = pktObj.hop_log;\n    this.msg_type = pktObj.msg_type;\n    this.hop_seq = pktObj.hop_seq;\n    this.hop_dir = pktObj.hop_dir;\n    this.hop_rsvp = pktObj.hop_rsvp;\n    this.err = pktObj.err;\n    this.auth = pktObj.auth;\n    return this;\n  }\n  /** packet transport  - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** rsvp required? */\n  isRsvp() {\n    return this.hop_rsvp;\n  }\n  lastHop() {\n    return this.hop_seq[this.hop_seq.length - 1];\n  }\n  /** types that begin with _ are protocol messages that bypass pktReceive() */\n  isProtocol() {\n    return this.msg_type.startsWith(\"_\");\n  }\n  isRequest() {\n    return this.hop_dir === \"req\";\n  }\n  isResponse() {\n    return this.hop_dir === \"res\";\n  }\n  /** serialization - - - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  serialize() {\n    return JSON.stringify(this);\n  }\n  deserialize(data) {\n    try {\n      let obj = JSON.parse(data);\n      return this.setFromObject(obj);\n    } catch (err) {\n      LOG(\"NetPacket.deserialize failed\", data);\n    }\n  }\n  /** information utilities - - - - - - - - - - - - - - - - - - - - - - - - **/\n  isValidType(type) {\n    return IsValidType(type);\n  }\n  isValidMessage(msg) {\n    return IsValidMessage(msg) !== void 0;\n  }\n  decodeMessage(msg) {\n    return DecodeMessage(msg);\n  }\n  /** debugging - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** add error string to packet error */\n  error(msg) {\n    if (!this.err)\n      this.err = \"\";\n    this.err += msg;\n    return msg;\n  }\n  /** manually add a transport-related message eto the hog log. this is not\n   *  the same as hop_seq which is used to track the routing of the packet.\n   */\n  hopLog(msg) {\n    const info = `${this.id} ${this.hop_dir}`;\n    this.hop_log.push(`${info}: ${msg}`);\n    return msg;\n  }\n};\n\n// _ur_addons/net/class-urnet-endpoint.ts\nvar DBG = false;\nvar PR3 = typeof process !== \"undefined\" ? \"EndPoint\".padEnd(13) : \"EndPoint:\";\nvar LOG2 = (...args) => DBG && console.log(PR3, ...args);\nvar AGE_INTERVAL = 1e3;\nvar AGE_MAX = 60 * 30;\nfunction _PKT(ep, fn, text, pkt) {\n  let { id, msg, msg_type } = pkt;\n  if (id === void 0 && msg_type === \"_reg\")\n    id = `pkt[${UADDR_NONE}:0]`;\n  let out = `${ep.urnet_addr} ${text} '${msg}' `.padEnd(40, \"~\");\n  out += ` ${id.padEnd(12)} ${fn}`;\n  return out;\n}\nvar NetEndpoint = class {\n  // client registration status\n  constructor() {\n    __publicField(this, \"urnet_addr\");\n    // the address for this endpoint\n    //\n    __publicField(this, \"cli_gateway\");\n    // gateway to server\n    __publicField(this, \"srv_socks\");\n    // uaddr->I_NetSocket\n    __publicField(this, \"srv_msgs\");\n    // msg->uaddr[]\n    __publicField(this, \"msg_handlers\");\n    // msg->handlers[]\n    __publicField(this, \"transactions\");\n    // hash->resolver\n    //\n    __publicField(this, \"cli_counter\");\n    // counter for generating unique uaddr\n    __publicField(this, \"pkt_counter\");\n    // counter for generating packet ids\n    //\n    __publicField(this, \"cli_sck_timer\");\n    // timer for checking socket age\n    __publicField(this, \"cli_ident\");\n    // client credentials to request authentication\n    __publicField(this, \"cli_auth\");\n    // client access token for\n    __publicField(this, \"cli_reg\");\n    this.urnet_addr = void 0;\n    this.cli_ident = void 0;\n    this.cli_auth = void 0;\n    this.cli_reg = void 0;\n    this.cli_gateway = void 0;\n    this.srv_socks = void 0;\n    this.srv_msgs = void 0;\n    this.msg_handlers = /* @__PURE__ */ new Map();\n    this.transactions = /* @__PURE__ */ new Map();\n    this.pkt_counter = 0;\n    this.cli_counter = 0;\n    this.cli_sck_timer = null;\n  }\n  /** client connection management  - - - - - - - - - - - - - - - - - - - - **/\n  /** return true if this endpoint is managing connections */\n  configAsServer(srv_addr) {\n    const fn = \"configAsServer:\";\n    if (!IsValidAddress(srv_addr))\n      throw Error(`${fn} invalid srv_addr ${srv_addr}`);\n    if (this.urnet_addr && this.urnet_addr !== srv_addr) {\n      let err = `${fn} urnet_addr ${this.urnet_addr} already set.`;\n      err += `currently, `;\n      throw Error(err);\n    }\n    this.urnet_addr = srv_addr;\n    if (this.srv_socks !== void 0)\n      LOG2(this.urnet_addr, `already configured`, [...this.srv_socks.keys()]);\n    this.srv_socks = /* @__PURE__ */ new Map();\n    if (this.srv_msgs !== void 0)\n      LOG2(this.urnet_addr, `already configured`, [...this.srv_msgs.keys()]);\n    this.srv_msgs = /* @__PURE__ */ new Map();\n    this.registerMessage(\"SRV:REFLECT\", (data) => {\n      return { memo: \"defaults defined in Endpoint.configAsServer\" };\n    });\n  }\n  /** return true if this endpoint is managing connections */\n  isServer() {\n    return this.srv_socks !== void 0 && this.srv_msgs !== void 0;\n  }\n  /** socket utilities  - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** given a socket, see if it's already registered */\n  isNewSocket(socket) {\n    const fn = \"isNewSocket:\";\n    if (typeof socket !== \"object\")\n      return false;\n    return socket.uaddr === void 0;\n  }\n  /** client endpoints need to have an authentication token to\n   *  access URNET beyond registration\n   */\n  authorizeSocket(auth) {\n    const fn = \"authorizeSocket:\";\n    LOG2(this.urnet_addr, \"would check auth token\");\n  }\n  /** return true if this socket passes authentication status */\n  isAuthorizedSocket(socket) {\n    const fn = \"authorizeSocket:\";\n    LOG2(fn, \"would check JWT in socket.auth\");\n    LOG2(this.urnet_addr, \"would check JWT in socket.auth\");\n    if (!socket.auth)\n      return false;\n    return true;\n  }\n  /** endpoint client management  - - - - - - - - - - - - - - - - - - - - - **/\n  /** Server data event handler for incoming data from a client connection.\n   *  This is the mirror to _serverDataIngest() function used by client endpoints.\n   * This is the entry point for incoming data from clients */\n  _clientDataIngest(jsonData, socket) {\n    let pkt = this.newPacket().deserialize(jsonData);\n    let retPkt;\n    retPkt = this.handleClientAuth(pkt, socket);\n    if (retPkt)\n      return retPkt;\n    retPkt = this.handleClientReg(pkt, socket);\n    if (retPkt)\n      return retPkt;\n    retPkt = this.handleClientDeclare(pkt, socket);\n    if (retPkt)\n      return retPkt;\n    if (pkt.auth) {\n      LOG2(\".. would check authentication token\");\n      this.pktReceive(pkt);\n      return;\n    }\n    pkt.setDir(\"res\");\n    pkt.addHop(this.urnet_addr);\n    pkt.data = { error: \"unauthorized packet rejected\" };\n    return pkt;\n  }\n  /** handle auth packet */\n  handleClientAuth(pkt, socket) {\n    if (socket.auth === void 0) {\n      pkt.setDir(\"res\");\n      pkt.addHop(this.urnet_addr);\n      if (pkt.msg_type === \"_auth\") {\n        if (pkt.msg !== \"SRV:AUTH\") {\n          pkt.data = { error: `invalid auth packet ${pkt.msg}` };\n          return pkt;\n        }\n      }\n      const { identity } = pkt.data;\n      if (identity) {\n        socket.auth = identity;\n        pkt.data = { uaddr: socket.uaddr, cli_auth: \"AnAuthToken\" };\n      } else {\n        pkt.data = { error: \"invalid identity\" };\n      }\n      return pkt;\n    }\n    return void 0;\n  }\n  /** handle registration packet */\n  handleClientReg(pkt, socket) {\n    if (pkt.msg_type === \"_reg\") {\n      pkt.setDir(\"res\");\n      pkt.addHop(this.urnet_addr);\n      if (pkt.msg !== \"SRV:REG\") {\n        pkt.data = { error: `invalid reg packet ${pkt.msg}` };\n        return pkt;\n      }\n      if (pkt.src_addr !== socket.uaddr) {\n        LOG2(\"src address mismatch\", pkt.src_addr, \"!= sock\", socket.uaddr);\n        pkt.data = { error: \"address mismatch\" };\n        return pkt;\n      }\n      const { name, type } = pkt.data;\n      if (name) {\n        const { uaddr } = socket;\n        pkt.data = { ok: true, status: `registered name:${name} type:${type}` };\n        return pkt;\n      }\n      pkt.data = { error: \"registration failed\" };\n      return pkt;\n    }\n    return void 0;\n  }\n  /** handle client dynamic definitions */\n  handleClientDeclare(pkt, socket) {\n    if (pkt.msg_type === \"_decl\") {\n      pkt.setDir(\"res\");\n      pkt.addHop(this.urnet_addr);\n      if (pkt.msg !== \"SRV:DEF\") {\n        pkt.data = { error: `invalid def packet ${pkt.msg}` };\n        return pkt;\n      }\n      pkt.data.status = [];\n      const { msg_list } = pkt.data;\n      const { uaddr } = socket;\n      if (Array.isArray(msg_list)) {\n        this.registerRemoteMessages(uaddr, msg_list);\n        pkt.data.status.push(`registered ${msg_list.length} messages`);\n      }\n      if (pkt.data.status.length === 0) {\n        pkt.data = { error: \"no definitions\" };\n        return pkt;\n      }\n    }\n    return void 0;\n  }\n  /** when a client connects to this endpoint, register it as a socket and\n   *  allocate a uaddr for it */\n  addClient(socket) {\n    const fn = \"addClient:\";\n    if (typeof socket !== \"object\")\n      throw Error(`${fn} invalid socket`);\n    if (socket.uaddr !== void 0)\n      throw Error(`${fn} socket already added`);\n    const new_uaddr = AllocateAddress({ prefix: \"UR_\" });\n    socket.uaddr = new_uaddr;\n    socket.age = 0;\n    socket.auth = void 0;\n    socket.msglist = void 0;\n    this.srv_socks.set(new_uaddr, socket);\n    return new_uaddr;\n  }\n  /** given a uaddr, return the socket */\n  getClient(uaddr) {\n    const fn = \"getClient:\";\n    if (this.srv_socks === void 0)\n      return void 0;\n    return this.srv_socks.get(uaddr);\n  }\n  /** when a client disconnects from this endpoint, delete its socket and\n   *  remove all message forwarding */\n  removeClient(uaddr_obj) {\n    const fn = \"removeClient:\";\n    let uaddr = typeof uaddr_obj === \"string\" ? uaddr_obj : uaddr_obj.uaddr;\n    if (typeof uaddr !== \"string\") {\n      LOG2(`${fn} invalid uaddr ${typeof uaddr}`);\n      return void 0;\n    }\n    if (!this.srv_socks.has(uaddr))\n      throw Error(`${fn} unknown uaddr ${uaddr}`);\n    this._delRemoteMessages(uaddr);\n    this.srv_socks.delete(uaddr);\n    return uaddr;\n  }\n  /** start a timer to check for dead sockets */\n  enableClientAging(activate) {\n    const fn = \"enableClientAging:\";\n    if (activate) {\n      if (this.cli_sck_timer)\n        clearInterval(this.cli_sck_timer);\n      this.cli_sck_timer = setInterval(() => {\n        this.srv_socks.forEach((socket, uaddr) => {\n          socket.age += AGE_INTERVAL;\n          if (socket.age > AGE_MAX) {\n            if (DBG)\n              LOG2(this.urnet_addr, `socket ${uaddr} expired`);\n          }\n        });\n      }, AGE_INTERVAL);\n      return;\n    }\n    if (this.cli_sck_timer)\n      clearInterval(this.cli_sck_timer);\n    this.cli_sck_timer = null;\n    if (DBG)\n      LOG2(this.urnet_addr, `timer stopped`);\n  }\n  /** client connection handshaking - - - - - - - - - - - - - - - - - - - - **/\n  /** Client data event handler for incoming data from the gateway.\n   *  This is the mirror to _clientDataIngest() function that is used by servers.\n   *  This is entry point for incoming data from server */\n  _serverDataIngest(jsonData, socket) {\n    const fn = \"_serverDataIngest:\";\n    const pkt = this.newPacket().deserialize(jsonData);\n    if (this.cli_gateway) {\n      if (this.handleAuthResponse(pkt))\n        return;\n      if (this.handleRegResponse(pkt))\n        return;\n    }\n    this.pktReceive(pkt);\n  }\n  /** client endpoints need to have an \"address\" assigned to them, otherwise\n   *  the endpoint will not work */\n  async connectAsClient(gateway, auth) {\n    const fn = \"connectAsClient:\";\n    if (gateway && typeof gateway.send === \"function\") {\n      this.cli_gateway = gateway;\n    } else\n      throw Error(`${fn} invalid gateway`);\n    if (auth) {\n      const pkt = this.newAuthPacket(auth);\n      const { msg } = pkt;\n      const requestAuth = new Promise((resolve, reject) => {\n        const hash = GetPacketHashString(pkt);\n        if (this.transactions.has(hash))\n          throw Error(`${fn} duplicate hash ${hash}`);\n        const meta = { msg, uaddr: this.urnet_addr };\n        this.transactions.set(hash, { resolve, reject, ...meta });\n        try {\n          this.cli_gateway.send(pkt);\n        } catch (err) {\n          reject(err);\n        }\n      });\n      let authData = await requestAuth;\n      const { uaddr, cli_auth, error } = authData;\n      if (error) {\n        LOG2(`${fn} error:`, error);\n        return false;\n      }\n      if (!IsValidAddress(uaddr))\n        throw Error(`${fn} invalid uaddr ${uaddr}`);\n      this.urnet_addr = uaddr;\n      if (cli_auth === void 0)\n        throw Error(`${fn} invalid cli_auth`);\n      this.cli_auth = cli_auth;\n      LOG2(\"** AUTHENTICATED **\", uaddr, cli_auth);\n      this.cli_auth = cli_auth;\n      return authData;\n    }\n    throw Error(`${fn} arg must be identity`);\n  }\n  /** create a authentication packet, which is the first packet that must be sent\n   *  after connecting to the server */\n  newAuthPacket(authObj) {\n    const pkt = this.newPacket(\"SRV:AUTH\", { ...authObj });\n    pkt.setMeta(\"_auth\", { rsvp: true });\n    pkt.setSrcAddr(UADDR_NONE);\n    this.assignPacketId(pkt);\n    return pkt;\n  }\n  /** handle authentication response packet directly rather than through\n   *  the netcall interface in pktReceive() */\n  handleAuthResponse(pkt) {\n    const fn = \"handleAuthResponse:\";\n    if (pkt.msg_type !== \"_auth\")\n      return false;\n    if (pkt.hop_dir !== \"res\")\n      return false;\n    this.pktResolveRequest(pkt);\n    return true;\n  }\n  /** register client with client endpoint info */\n  async registerClient(info) {\n    const fn = \"registerClient:\";\n    if (!this.cli_gateway)\n      throw Error(`${fn} no gateway`);\n    const pkt = this.newRegPacket();\n    pkt.data = { ...info };\n    const { msg } = pkt;\n    const requestReg = new Promise((resolve, reject) => {\n      const hash = GetPacketHashString(pkt);\n      if (this.transactions.has(hash))\n        throw Error(`${fn} duplicate hash ${hash}`);\n      const meta = { msg, uaddr: this.urnet_addr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.cli_gateway.send(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    let regData = await requestReg;\n    const { ok, status, error } = regData;\n    if (error) {\n      LOG2(`${fn} error:`, error);\n      return regData;\n    }\n    if (ok) {\n      LOG2(\"** REGISTERED **\", status);\n      this.cli_reg = info;\n      return regData;\n    }\n    throw Error(`${fn} unexpected response`, regData);\n  }\n  /** create a registration packet */\n  newRegPacket() {\n    const pkt = this.newPacket(\"SRV:REG\");\n    pkt.setMeta(\"_reg\", { rsvp: true });\n    return pkt;\n  }\n  /** handle registration response packet directly rather than through\n   *  the netcall interface in pktReceive() */\n  handleRegResponse(pkt) {\n    const fn = \"handleRegResponse:\";\n    if (pkt.msg_type !== \"_reg\")\n      return false;\n    if (pkt.hop_dir !== \"res\")\n      return false;\n    if (pkt.src_addr !== this.urnet_addr)\n      throw Error(`${fn} misaddressed packet???`);\n    this.pktResolveRequest(pkt);\n    return true;\n  }\n  /** declare client messages */\n  async clientDeclare() {\n    const msg_list = this.listNetMessages();\n    return await this.clientDeclareServices({ msg_list });\n  }\n  /** declare client attributes */\n  async clientDeclareServices(def) {\n    const fn = \"clientDeclareServices:\";\n    if (!this.cli_gateway)\n      throw Error(`${fn} no gateway`);\n    const pkt = this.newDeclPacket();\n    pkt.data = { ...def };\n    const { msg } = pkt;\n    const decSvcs = new Promise((resolve, reject) => {\n      const hash = GetPacketHashString(pkt);\n      if (this.transactions.has(hash))\n        throw Error(`${fn} duplicate hash ${hash}`);\n      const meta = { msg, uaddr: this.urnet_addr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.cli_gateway.send(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    let declared = await decSvcs;\n    const { error, status } = declared;\n    if (error) {\n      LOG2(`${fn} error:`, error);\n      return declared;\n    }\n    if (status) {\n      LOG2(\"** DECLARED **\", status);\n      return declared;\n    }\n    throw Error(`${fn} unexpected response`, declared);\n  }\n  /** create a definition packet */\n  newDeclPacket() {\n    const pkt = this.newPacket(\"SRV:DEF\");\n    pkt.setMeta(\"_decl\", { rsvp: true });\n    return pkt;\n  }\n  handleDeclResponse(pkt) {\n    const fn = \"handleDeclResponse:\";\n    if (pkt.msg_type !== \"_decl\")\n      return false;\n    if (pkt.hop_dir !== \"res\")\n      return false;\n    if (pkt.src_addr !== this.urnet_addr)\n      throw Error(`${fn} misaddressed packet???`);\n    this.pktResolveRequest(pkt);\n    return true;\n  }\n  /** disables down the gateway */\n  disconnectAsClient() {\n    this.cli_gateway = void 0;\n  }\n  /** endpoint lookup tables - - - - - - - - - - - - - - - - - - - -  - - - **/\n  /** get list of messages allocated to a uaddr */\n  getMessagesForAddress(uaddr) {\n    const fn = \"getMessagesForAddress:\";\n    if (!this.isServer())\n      return [];\n    if (typeof uaddr !== \"string\")\n      throw Error(`${fn} invalid uaddr`);\n    if (!this.srv_socks.has(uaddr))\n      throw Error(`${fn} unknown uaddr ${uaddr}`);\n    const msg_list = [];\n    this.srv_msgs.forEach((addr_set, msg) => {\n      if (addr_set.has(uaddr))\n        msg_list.push(msg);\n    });\n    return msg_list;\n  }\n  /** get list of UADDRs that a message is forwarded to */\n  getAddressesForMessage(msg) {\n    const fn = \"getAddressesForMessage:\";\n    if (!this.isServer())\n      return [];\n    if (typeof msg !== \"string\")\n      throw Error(`${fn} invalid msg`);\n    const key = NormalizeMessage(msg);\n    if (!this.srv_msgs.has(key))\n      this.srv_msgs.set(key, /* @__PURE__ */ new Set());\n    const addr_set = this.srv_msgs.get(key);\n    const addr_list = Array.from(addr_set);\n    return addr_list;\n  }\n  /** return list of local handlers for given message */\n  getHandlersForMessage(msg) {\n    const fn = \"getHandlersForMessage:\";\n    if (typeof msg !== \"string\")\n      throw Error(`${fn} invalid msg`);\n    const key = NormalizeMessage(msg);\n    if (!this.msg_handlers.has(key))\n      this.msg_handlers.set(key, /* @__PURE__ */ new Set());\n    const handler_set = this.msg_handlers.get(key);\n    if (!handler_set)\n      throw Error(`${fn} unexpected empty set '${key}'`);\n    const handler_list = Array.from(handler_set);\n    return handler_list;\n  }\n  /** informational routing information - - - - - - - - - - - - - - - - - - **/\n  /** return handler list for this endpoint */\n  listMessages() {\n    const list = [];\n    this.msg_handlers.forEach((handler_set, key) => {\n      list.push(key);\n    });\n    return list;\n  }\n  /** return only net messages */\n  listNetMessages() {\n    const list = [];\n    this.msg_handlers.forEach((handler_set, key) => {\n      if (IsNetMessage(key))\n        list.push(key);\n    });\n    return list;\n  }\n  /** return list of active transactions for this endpoint */\n  listTransactions() {\n    const fn = \"listTransactions:\";\n    const list = [];\n    this.transactions.forEach((transaction, hash) => {\n      const { msg, uaddr } = transaction;\n      list.push({ hash, msg, uaddr });\n    });\n    return list;\n  }\n  /** server endpoints manage list of messages in clients  - - - - -  - - - **/\n  /** register a message handler for a given message to passed uaddr */\n  registerRemoteMessages(uaddr, msgList) {\n    const fn = \"registerRemoteMessages:\";\n    if (typeof uaddr !== \"string\")\n      throw Error(`${fn} invalid uaddr`);\n    if (!this.srv_socks.has(uaddr))\n      throw Error(`${fn} unknown uaddr ${uaddr}`);\n    this._setRemoteMessages(uaddr, msgList);\n  }\n  /** secret utility function for registerRemoteMessages */\n  _setRemoteMessages(uaddr, msgList) {\n    const fn = \"_setRemoteMessages:\";\n    msgList.forEach((msg) => {\n      if (typeof msg !== \"string\")\n        throw Error(`${fn} invalid msg`);\n      if (msg !== msg.toUpperCase())\n        throw Error(`${fn} msg must be uppercase`);\n      const key = NormalizeMessage(msg);\n      if (!this.srv_msgs.has(key))\n        this.srv_msgs.set(key, /* @__PURE__ */ new Set());\n      const msg_set = this.srv_msgs.get(key);\n      msg_set.add(uaddr);\n    });\n  }\n  /** unregister message handlers for a given message to passed uaddr */\n  _delRemoteMessages(uaddr) {\n    const fn = \"_delRemoteMessages:\";\n    if (typeof uaddr !== \"string\")\n      throw Error(`${fn} invalid uaddr`);\n    if (!this.srv_socks.has(uaddr))\n      throw Error(`${fn} unknown uaddr ${uaddr}`);\n    const removed = [];\n    this.srv_msgs.forEach((msg_set, key) => {\n      if (msg_set.has(uaddr))\n        removed.push(key);\n      msg_set.delete(uaddr);\n    });\n    return removed;\n  }\n  /** packet utility - - - - - - - - - - - - - - - - - - - - - - - - - - - -**/\n  assignPacketId(pkt) {\n    if (pkt.src_addr === void 0)\n      pkt.src_addr = this.urnet_addr;\n    const count = ++this.pkt_counter;\n    pkt.id = `pkt[${pkt.src_addr}:${count}]`;\n    return pkt.id;\n  }\n  /** convert JSON to packet and return */\n  packetFromJSON(json) {\n    const pkt = new NetPacket();\n    pkt.setFromJSON(json);\n    return pkt;\n  }\n  /** create a new packet with proper address */\n  newPacket(msg, data) {\n    const fn = \"newPacket:\";\n    const pkt = new NetPacket(msg, data);\n    pkt.setSrcAddr(this.urnet_addr || UADDR_NONE);\n    if (this.cli_auth)\n      pkt.setAuth(this.cli_auth);\n    pkt.id = this.assignPacketId(pkt);\n    return pkt;\n  }\n  /** clone a packet with new id */\n  clonePacket(pkt) {\n    const clone = this.newPacket(pkt.msg, pkt.data);\n    clone.setFromJSON(pkt.serialize());\n    clone.src_addr = this.urnet_addr;\n    clone.id = this.assignPacketId(clone);\n    return clone;\n  }\n  /** message declaration and invocation - - - - - - - - - - - - - - - - - -**/\n  /** declare a message handler for a given message */\n  registerMessage(msg, handler) {\n    const fn = \"registerMessage:\";\n    if (typeof msg !== \"string\")\n      throw Error(`${fn} invalid msg`);\n    if (msg !== msg.toUpperCase())\n      throw Error(`${fn} msg must be uppercase`);\n    if (typeof handler !== \"function\")\n      throw Error(`${fn} invalid handler`);\n    const key = NormalizeMessage(msg);\n    if (!this.msg_handlers.has(key))\n      this.msg_handlers.set(key, /* @__PURE__ */ new Set());\n    const handler_set = this.msg_handlers.get(key);\n    handler_set.add(handler);\n  }\n  /** remove a previously declared message handler for a given message */\n  removeHandler(msg, handler) {\n    const fn = \"removeHandler:\";\n    if (typeof msg !== \"string\")\n      throw Error(`${fn} invalid msg`);\n    if (typeof handler !== \"function\")\n      throw Error(`${fn} invalid handler`);\n    const key = NormalizeMessage(msg);\n    const handler_set = this.msg_handlers.get(key);\n    if (!handler_set)\n      throw Error(`${fn} unexpected empty set '${key}'`);\n    handler_set.delete(handler);\n  }\n  /** call local message registered on this endPoint only */\n  async call(msg, data) {\n    const fn = \"call:\";\n    if (!IsLocalMessage(msg))\n      throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getHandlersForMessage(msg);\n    const promises = [];\n    handlers.forEach((handler) => {\n      promises.push(\n        new Promise((resolve, reject) => {\n          try {\n            resolve(handler({ ...data }));\n          } catch (err) {\n            reject(err);\n          }\n        })\n      );\n    });\n    if (promises.length === 0)\n      return Promise.resolve({ error: `no handler for '${msg}'` });\n    const resData = await Promise.all(promises);\n    return resData;\n  }\n  /** send local message registered on this endPoint only, returning no data */\n  async send(msg, data) {\n    const fn = \"send:\";\n    if (!IsLocalMessage(msg))\n      throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getHandlersForMessage(msg);\n    if (handlers.length === 0)\n      return Promise.resolve({ error: `no handler for '${msg}'` });\n    handlers.forEach((handler) => {\n      handler({ ...data });\n    });\n    return Promise.resolve(true);\n  }\n  /** signal local message registered on this endPoint only, returning no data.\n   */\n  async signal(msg, data) {\n    const fn = \"signal:\";\n    if (!IsLocalMessage(msg))\n      throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getHandlersForMessage(msg);\n    if (handlers.length === 0)\n      return Promise.resolve({ error: `no handler for '${msg}'` });\n    handlers.forEach((handler) => {\n      handler({ ...data });\n    });\n    return Promise.resolve(true);\n  }\n  /** ping local message, return with number of handlers */\n  async ping(msg) {\n    const fn = \"ping:\";\n    if (!IsLocalMessage(msg))\n      throw Error(`${fn} '${msg}' not local (drop prefix)`);\n    const handlers = this.getHandlersForMessage(msg);\n    return Promise.resolve(handlers.length);\n  }\n  /** call net message, resolves when packet returns from server with data */\n  async netCall(msg, data) {\n    const fn = \"netCall:\";\n    if (!IsNetMessage(msg))\n      throw Error(`${fn} '${msg}' missing NET prefix`);\n    const pkt = this.newPacket(msg, data);\n    pkt.setMeta(\"call\", {\n      dir: \"req\",\n      rsvp: true\n    });\n    const p = new Promise((resolve, reject) => {\n      const hash = GetPacketHashString(pkt);\n      if (this.transactions.has(hash))\n        throw Error(`${fn} duplicate hash ${hash}`);\n      const meta = { msg, uaddr: this.urnet_addr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.pktSendRequest(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    let resData = await p;\n    return resData;\n  }\n  /** send net message, returning promise that will resolve when the server has\n   *  received and processed/forwarded the message */\n  async netSend(msg, data) {\n    const fn = \"netSend:\";\n    if (!IsNetMessage(msg))\n      throw Error(`${fn} '${msg}' missing NET prefix`);\n    const p = new Promise((resolve, reject) => {\n      const pkt = this.newPacket(msg, data);\n      pkt.setMeta(\"send\", {\n        dir: \"req\",\n        rsvp: true\n      });\n      const hash = GetPacketHashString(pkt);\n      if (this.transactions.has(hash))\n        throw Error(`${fn} duplicate hash ${hash}`);\n      const meta = { msg, uaddr: this.urnet_addr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.pktSendRequest(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    let resData = await p;\n    return resData;\n  }\n  /** signal net message, returning void (not promise)\n   *  used for the idea of 'raising signals' as opposed to 'sending data'. It\n   *  resolves immediately when the signal is sent, and does not check with the\n   *  server  */\n  netSignal(msg, data) {\n    const fn = \"netSignal:\";\n    if (!IsNetMessage(msg))\n      throw Error(`${fn} '${msg}' missing NET prefix`);\n    const pkt = this.newPacket(msg, data);\n    pkt.setMeta(\"signal\", {\n      dir: \"req\",\n      rsvp: false\n    });\n    this.pktSendRequest(pkt);\n  }\n  /** returns with a list of uaddr from the server which is the uaddr of the\n   *  all clients that have registered for the message */\n  async netPing(msg) {\n    const fn = \"netPing:\";\n    if (!IsNetMessage(msg))\n      throw Error(`${fn} '${msg}' missing NET prefix`);\n    const pkt = this.newPacket(msg);\n    pkt.setMeta(\"ping\", {\n      dir: \"req\",\n      rsvp: true\n    });\n    const p = new Promise((resolve, reject) => {\n      const hash = GetPacketHashString(pkt);\n      if (this.transactions.has(hash))\n        throw Error(`${fn} duplicate hash ${hash}`);\n      const meta = { msg, uaddr: this.urnet_addr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      try {\n        this.pktSendRequest(pkt);\n      } catch (err) {\n        reject(err);\n      }\n    });\n    let resData = await p;\n    return resData;\n  }\n  /** packet interface  - - - - - - - - - - - - - - - - - - - - - - - - - - **/\n  /** Receive a single packet from the wire, and determine\n   *  what to do with it. The packet has several possible\n   *  processing options!\n   *  - packet is response to an outgoing transaction\n   *  - packet is a message that we handle\n   *  - packet is a message that we forward\n   *  - packet is unknown message so we return it with error\n   *  If the packet has the rsvp flag set, we need to return\n   *  it to the source address in the packet with any data\n   */\n  async pktReceive(pkt) {\n    try {\n      const fn = \"pktReceive:\";\n      if (pkt.isResponse()) {\n        if (pkt.src_addr === this.urnet_addr)\n          this.pktResolveRequest(pkt);\n        else\n          this.pktSendResponse(pkt);\n        return;\n      }\n      if (!pkt.isRequest()) {\n        LOG2(this.urnet_addr, fn, `invalid packet`, pkt);\n        return;\n      }\n      if (pkt.msg_type === \"ping\") {\n        const addrs = this.getAddressesForMessage(pkt.msg);\n        const handlers = this.getHandlersForMessage(pkt.msg);\n        if (handlers.length > 0)\n          addrs.push(this.urnet_addr);\n        pkt.setData(addrs);\n        this.pktSendResponse(pkt);\n        return;\n      }\n      if (pkt.msg_type === \"signal\") {\n        if (DBG)\n          LOG2(_PKT(this, fn, \"-recv-sig-\", pkt), pkt.data);\n        LOG2(\"would handle signal\", pkt.msg);\n      }\n      const { msg } = pkt;\n      let retData;\n      if (this.msg_handlers.has(msg)) {\n        retData = await this.pktAwaitHandlers(pkt);\n      } else if (this.srv_msgs.has(msg)) {\n        retData = await this.pktAwaitRequest(pkt);\n      } else {\n        LOG2(this.urnet_addr, fn, `unknown message '${msg}'`, pkt);\n        retData = { error: `unknown message '${msg}'` };\n      }\n      if (!pkt.isRsvp())\n        return;\n      if (pkt.msg_type !== \"call\")\n        pkt.data = true;\n      else {\n        retData = NormalizeData(retData);\n        pkt.setData(retData);\n      }\n      this.pktSendResponse(pkt);\n    } catch (err) {\n      LOG2(err.message);\n      LOG2(err.stack.split(\"\\n\").slice(1).join(\"\\n\").trim());\n    }\n  }\n  /** Send a single packet on all available interfaces based on the\n   *  message. And endpoint can be a client (with gateway) or a server\n   *  (with clients). Use for initial outgoing packets only.\n   */\n  pktSendRequest(pkt) {\n    const fn = \"pktSendRequest:\";\n    if (pkt.src_addr === void 0)\n      throw Error(`${fn}src_addr undefined`);\n    if (this.urnet_addr === void 0)\n      throw Error(`${fn} urnet_addr undefined`);\n    if (pkt.hop_seq.length !== 0)\n      throw Error(`${fn} pkt must have no hops yet`);\n    if (pkt.msg_type !== \"ping\" && pkt.data === void 0)\n      throw Error(`${fn} data undefined`);\n    if (DBG)\n      LOG2(_PKT(this, fn, \"-send-req-\", pkt), pkt.data);\n    const { gateway, clients } = this.pktGetSocketRouting(pkt);\n    pkt.addHop(this.urnet_addr);\n    if (gateway) {\n      if (this.cli_reg === void 0)\n        throw Error(`${fn} endpoint not registered`);\n      gateway.send(pkt);\n    }\n    if (Array.isArray(clients)) {\n      clients.forEach((sock) => sock.send(pkt));\n    }\n  }\n  /** Given a packet and a socket, clone it and then return a\n   *  promise that sends it out on all network interfaces. This\n   *  is used by server endpoints as a utility to send a clone\n   *  packet on a particular socket to a particular address.\n   */\n  pktQueueRequest(pkt, sock) {\n    const fn = \"pktQueueRequest:\";\n    const clone = this.clonePacket(pkt);\n    clone.id = this.assignPacketId(clone);\n    const hash = GetPacketHashString(clone);\n    if (this.transactions.has(hash))\n      throw Error(`${fn} duplicate hash ${hash}`);\n    const p = new Promise((resolve, reject) => {\n      const meta = { msg: pkt.msg, uaddr: pkt.src_addr };\n      this.transactions.set(hash, { resolve, reject, ...meta });\n      sock.send(clone);\n    });\n    return p;\n  }\n  /** Resolve a transaction when a packet is returned to it through\n   *  pktReceive(pkt) which determines that it is a returning transaction\n   */\n  pktResolveRequest(pkt) {\n    const fn = \"pktResolveRequest:\";\n    if (pkt.hop_rsvp !== true)\n      throw Error(`${fn} packet is not RSVP`);\n    if (pkt.hop_dir !== \"res\")\n      throw Error(`${fn} packet is not a response`);\n    if (pkt.hop_seq.length < 2 && !pkt.isProtocol())\n      throw Error(`${fn} packet has no hops`);\n    const hash = GetPacketHashString(pkt);\n    const resolver = this.transactions.get(hash);\n    if (!resolver)\n      throw Error(`${fn} no resolver for hash ${hash}`);\n    const { resolve, reject } = resolver;\n    const { data } = pkt;\n    if (DBG)\n      LOG2(_PKT(this, fn, \"-recv-res-\", pkt), pkt.data);\n    if (pkt.err)\n      reject(pkt.err);\n    else\n      resolve(data);\n    this.transactions.delete(hash);\n  }\n  /** Return a packet to its source address. If this endpoint is a server,\n   *  then it might have the socket stored. Otherwise, if this endpoint is\n   *  also a client of another server, pass the back through the gateway.\n   *  This is used by server endpoints to return packets to clients.\n   */\n  pktSendResponse(pkt) {\n    const fn = \"pktSendResponse:\";\n    if (pkt.hop_rsvp !== true)\n      throw Error(`${fn} packet is not RSVP`);\n    if (pkt.hop_seq.length < 1)\n      throw Error(`${fn} packet has no hops`);\n    pkt.setDir(\"res\");\n    pkt.addHop(this.urnet_addr);\n    if (DBG)\n      LOG2(_PKT(this, fn, \"-send-res-\", pkt), pkt.data);\n    const { gateway, src_addr } = this.pktGetSocketRouting(pkt);\n    if (this.isServer()) {\n      const socket = this.getClient(src_addr);\n      if (socket)\n        socket.send(pkt);\n      return;\n    }\n    if (gateway) {\n      gateway.send(pkt);\n      return;\n    }\n    if (DBG)\n      LOG2(`${fn} unroutable packet`, pkt);\n  }\n  /** Start a transaction, which returns promises to await. This method\n   *  is a queue that uses Promises to wait for the return, which is\n   *  triggered by a returning packet in pktReceive(pkt).\n   */\n  async pktAwaitRequest(pkt) {\n    const fn = \"pktAwaitRequest:\";\n    if (pkt.hop_dir !== \"req\")\n      throw Error(`${fn} packet is not a request`);\n    const { gateway, clients } = this.pktGetSocketRouting(pkt);\n    const promises = [];\n    if (gateway) {\n      if (DBG)\n        LOG2(_PKT(this, fn, \"-wait-req-\", pkt), pkt.data);\n      promises.push(this.pktQueueRequest(pkt, gateway));\n    }\n    if (Array.isArray(clients)) {\n      if (DBG)\n        LOG2(_PKT(this, fn, \"-wait-req-\", pkt), pkt.data);\n      clients.forEach((sock) => {\n        promises.push(this.pktQueueRequest(pkt, sock));\n      });\n    }\n    let data = await Promise.all(promises);\n    if (Array.isArray(data) && data.length === 1)\n      data = data[0];\n    if (DBG)\n      LOG2(_PKT(this, fn, \"-retn-req-\", pkt), pkt.data);\n    return data;\n  }\n  /** Start a handler call, which might have multiple implementors.\n   *  Returns data from all handlers as an array or a single item\n   */\n  async pktAwaitHandlers(pkt) {\n    const fn = \"pktAwaitHandlers:\";\n    const { msg } = pkt;\n    const handlers = this.getHandlersForMessage(msg);\n    if (handlers.length === 0)\n      return Promise.resolve({ error: `no handler for '${msg}'` });\n    const promises = [];\n    if (DBG)\n      LOG2(_PKT(this, fn, \"-wait-hnd-\", pkt), pkt.data);\n    handlers.forEach((handler) => {\n      promises.push(\n        new Promise((resolve, reject) => {\n          try {\n            resolve(handler({ ...pkt.data }));\n          } catch (err) {\n            reject(err);\n          }\n        })\n      );\n    });\n    let data = await Promise.all(promises);\n    if (Array.isArray(data) && data.length === 1)\n      data = data[0];\n    if (DBG)\n      LOG2(_PKT(this, fn, \"-retn-hnd-\", pkt), pkt.data);\n    return data;\n  }\n  /** return array of sockets to use for sending packet,\n   *  based on pkt.msg and pkt.src_addr\n   */\n  pktGetSocketRouting(pkt) {\n    const fn = \"pktGetSocketRouting:\";\n    const { msg, src_addr } = pkt;\n    if (!IsNetMessage(msg))\n      throw Error(`${fn} '${msg}' is invalid message`);\n    const gateway = this.cli_gateway;\n    const self_addr = this.urnet_addr;\n    const msg_list = this.getAddressesForMessage(msg);\n    const clients = [];\n    msg_list.forEach((uaddr) => {\n      LOG2(\"uaddr\", uaddr);\n      if (uaddr === this.urnet_addr)\n        return;\n      const socket = this.getClient(uaddr);\n      if (socket)\n        clients.push(socket);\n    });\n    return {\n      msg,\n      src_addr,\n      self_addr,\n      gateway,\n      clients\n    };\n  }\n};\n\n// _ur_addons/net/class-urnet-socket.ts\nvar PR4 = typeof process !== \"undefined\" ? \"Socket\".padEnd(13) : \"Socket:\";\nvar NetSocket = class {\n  // name of the socket-ish object\n  constructor(connectObj, io) {\n    __publicField(this, \"connector\");\n    // the original connection object\n    __publicField(this, \"sendFunc\");\n    // the outgoing send function for this socket\n    __publicField(this, \"onDataFunc\");\n    // the incoming data function for this socket\n    //\n    __publicField(this, \"uaddr\");\n    // assigned uaddr for this socket-ish object\n    __publicField(this, \"auth\");\n    // whatever authentication is needed for this socket\n    __publicField(this, \"msglist\");\n    // messages queued for this socket\n    __publicField(this, \"age\");\n    // number of seconds since this socket was used\n    __publicField(this, \"label\");\n    this.connector = connectObj;\n    const { send, onData } = io;\n    this.sendFunc = send.bind(connectObj);\n    this.onDataFunc = onData.bind(connectObj);\n  }\n  send(pkt) {\n    this.sendFunc(pkt);\n  }\n  getConnector() {\n    return this.connector;\n  }\n};\n\n// _ur_addons/comment/ac-comment.ts\nvar ac_comment_exports = {};\n__export(ac_comment_exports, {\n  AddComment: () => AddComment2,\n  CloseCommentCollection: () => CloseCommentCollection,\n  DeriveAllThreadedViewObjects: () => DeriveAllThreadedViewObjects,\n  DeriveThreadedViewObjects: () => DeriveThreadedViewObjects,\n  GetCOMMENTVOBJS: () => GetCOMMENTVOBJS,\n  GetComment: () => GetComment2,\n  GetCommentBeingEdited: () => GetCommentBeingEdited,\n  GetCommentCollection: () => GetCommentCollection,\n  GetCommentCollections: () => GetCommentCollections,\n  GetCommentStats: () => GetCommentStats,\n  GetCommentTypes: () => GetCommentTypes2,\n  GetCommentUIState: () => GetCommentUIState,\n  GetCommentVObj: () => GetCommentVObj,\n  GetCrefs: () => GetCrefs2,\n  GetDateString: () => GetDateString,\n  GetOpenComments: () => GetOpenComments,\n  GetReadby: () => GetReadby2,\n  GetThreadedViewObjects: () => GetThreadedViewObjects,\n  GetThreadedViewObjectsCount: () => GetThreadedViewObjectsCount,\n  GetUnreadComments: () => GetUnreadComments,\n  GetUnreadRepliesToMe: () => GetUnreadRepliesToMe,\n  GetUserName: () => GetUserName2,\n  HandleRemovedComments: () => HandleRemovedComments2,\n  HandleUpdatedComments: () => HandleUpdatedComments2,\n  Init: () => Init2,\n  LoadDB: () => LoadDB2,\n  MarkRead: () => MarkRead,\n  RemoveAllCommentsForCref: () => RemoveAllCommentsForCref2,\n  RemoveComment: () => RemoveComment2,\n  UpdateComment: () => UpdateComment2,\n  UpdateCommentUIState: () => UpdateCommentUIState\n});\n\n// _ur_addons/comment/dc-comment.ts\nvar DBG2 = true;\nvar USERS = /* @__PURE__ */ new Map();\nvar COMMENTTYPES = /* @__PURE__ */ new Map();\nvar COMMENTS = /* @__PURE__ */ new Map();\nvar READBY = /* @__PURE__ */ new Map();\nvar ROOTS = /* @__PURE__ */ new Map();\nvar REPLY_ROOTS = /* @__PURE__ */ new Map();\nvar NEXT = /* @__PURE__ */ new Map();\nvar DEFAULT_CommentTypes = [\n  {\n    id: \"cmt\",\n    label: \"COMMENT\",\n    // comment type label\n    prompts: [\n      {\n        prompt: \"COMMENT\",\n        // prompt label\n        help: \"\",\n        feedback: \"\"\n      }\n    ]\n  },\n  {\n    id: \"questionresponse\",\n    label: \"Question or response\",\n    // comment type label\n    prompts: [\n      {\n        prompt: \"Question or response\",\n        // prompt label\n        help: \"\",\n        feedback: \"\"\n      }\n    ]\n  },\n  {\n    id: \"consistent\",\n    label: \"Consistent\",\n    // comment type label\n    prompts: [\n      {\n        prompt: \"Consistent\",\n        // prompt label\n        help: \"\",\n        feedback: \"\"\n      }\n    ]\n  },\n  {\n    id: \"understandable\",\n    label: \"Understandable\",\n    // comment type label\n    prompts: [\n      {\n        prompt: \"Understandable\",\n        // prompt label\n        help: \"\",\n        feedback: \"\"\n      }\n    ]\n  },\n  {\n    id: \"understandable\",\n    label: \"Supported by evidence\",\n    // comment type label\n    prompts: [\n      {\n        prompt: \"Supported by evidence\",\n        // prompt label\n        help: `It is important for a scientific model to be supported by evidence.\n\nDoes the evidence we have show that the model works this way?\nIs there any contradictory evidence that says the model doesn't work this way?\n`,\n        feedback: \"Consider pointing out relevant evidence by typing evidence #\"\n      }\n    ]\n  },\n  {\n    id: \"changereason\",\n    label: \"Change + Reason\",\n    // comment type label\n    prompts: [\n      {\n        prompt: \"Change\",\n        help: \"What change do you want to make?\",\n        feedback: \"\"\n      },\n      {\n        prompt: \"Reason\",\n        help: \"Why do you want to make that change\",\n        feedback: \"\"\n      }\n    ]\n  },\n  {\n    id: \"three\",\n    label: \"Three Points\",\n    // comment type label\n    prompts: [\n      {\n        prompt: \"Point 1\",\n        help: \"What change do you want to make?\",\n        feedback: \"\"\n      },\n      {\n        prompt: \"Point 2\",\n        help: \"Why do you want to make that change\",\n        feedback: \"\"\n      },\n      {\n        prompt: \"Point 3\",\n        help: \"Why do you want to make that change\",\n        feedback: \"\"\n      }\n    ]\n  }\n];\nfunction m_LoadUsers(dbUsers) {\n  dbUsers.forEach((u) => USERS.set(u.id, u.name));\n}\nfunction m_LoadCommentTypes(commentTypes) {\n  commentTypes.forEach((t) => COMMENTTYPES.set(t.id, t));\n}\nfunction m_LoadComments(comments) {\n  comments.forEach((c) => COMMENTS.set(c.comment_id, c));\n}\nfunction m_LoadReadBy(readby) {\n  readby.forEach((r) => READBY.set(r.comment_id, r.commenter_ids));\n}\nfunction Init() {\n  console.log(\"dc-comments Init\");\n  m_LoadCommentTypes(DEFAULT_CommentTypes);\n}\nfunction LoadDB(data) {\n  if (data.commenttypes)\n    m_LoadCommentTypes(data.commenttypes);\n  if (data.users)\n    m_LoadUsers(data.users);\n  if (data.comments)\n    m_LoadComments(data.comments);\n  if (data.readby)\n    m_LoadReadBy(data.readby);\n  if (DBG2)\n    console.log(\"USERS\", USERS);\n  if (DBG2)\n    console.log(\"COMMENTTYPES\", COMMENTTYPES);\n  if (DBG2)\n    console.log(\"COMMENTS\", COMMENTS);\n  if (DBG2)\n    console.log(\"READBY\", READBY);\n  m_DeriveValues();\n}\nfunction GetUsers() {\n  return USERS;\n}\nfunction GetUser(uid) {\n  return USERS.get(uid);\n}\nfunction GetUserName(uid) {\n  const u = USERS.get(uid);\n  return u !== void 0 ? u : uid;\n}\nfunction GetCurrentUser() {\n  return \"Ben32\";\n}\nfunction GetCommentTypes() {\n  return COMMENTTYPES;\n}\nfunction GetCommentType(typeid) {\n  return COMMENTTYPES.get(typeid);\n}\nfunction GetComments() {\n  return COMMENTS;\n}\nfunction GetComment(cid) {\n  return COMMENTS.get(cid);\n}\nfunction m_DeriveValues() {\n  ROOTS.clear();\n  REPLY_ROOTS.clear();\n  NEXT.clear();\n  COMMENTS.forEach((c) => {\n    if (c.comment_id_parent === \"\" && c.comment_id_previous === \"\")\n      ROOTS.set(c.collection_ref, c.comment_id);\n    if (c.comment_id_parent !== \"\" && c.comment_id_previous === \"\") {\n      REPLY_ROOTS.set(c.comment_id_parent, c.comment_id);\n    }\n    if (c.comment_id_previous !== \"\") {\n      NEXT.set(c.comment_id_previous, c.comment_id);\n    }\n  });\n  if (DBG2)\n    console.log(\"ROOTS\", ROOTS);\n  if (DBG2)\n    console.log(\"REPLY_ROOTS\", REPLY_ROOTS);\n  if (DBG2)\n    console.log(\"NEXT\", NEXT);\n}\nfunction AddComment(data) {\n  if (data.cref === void 0)\n    throw new Error(\"Comments must have a collection ref!\");\n  const comment_id_parent = data.comment_id_parent || \"\";\n  const comment_id_previous = data.comment_id_previous || \"\";\n  const comment = {\n    collection_ref: data.cref,\n    comment_id: data.comment_id,\n    // thread\n    comment_id_parent,\n    comment_id_previous,\n    comment_type: \"cmt\",\n    // default type, no prompts\n    comment_createtime: /* @__PURE__ */ new Date(),\n    comment_modifytime: \"\",\n    comment_isMarkedDeleted: data.comment_isMarkedDeleted,\n    commenter_id: data.commenter_id,\n    commenter_text: []\n  };\n  COMMENTS.set(comment.comment_id, comment);\n  m_DeriveValues();\n  return comment;\n}\nfunction UpdateComment(cobj) {\n  m_UpdateComment(cobj);\n  m_DeriveValues();\n}\nfunction m_UpdateComment(cobj) {\n  cobj.comment_modifytime = /* @__PURE__ */ new Date();\n  console.log(\n    \"REVIEW: UpdateComment...modify time should use loki time???\",\n    cobj.comment_modifytime\n  );\n  COMMENTS.set(cobj.comment_id, cobj);\n}\nfunction HandleUpdatedComments(cobjs) {\n  cobjs.forEach((cobj) => m_UpdateComment(cobj));\n  m_DeriveValues();\n}\nfunction RemoveComment(parms) {\n  const { collection_ref, comment_id, uid, isAdmin } = parms;\n  const queuedActions = [];\n  let deleteTarget = false;\n  let deleteTargetAndNext = false;\n  let deleteRootAndChildren = false;\n  let markDeleted = false;\n  let relinkNext = false;\n  const cidToDelete = comment_id;\n  const cobjToDelete = COMMENTS.get(cidToDelete);\n  const cobjIsRoot = cobjToDelete.comment_id_parent === \"\";\n  if (isAdmin) {\n    if (cobjIsRoot) {\n      deleteRootAndChildren = true;\n      relinkNext = true;\n    } else {\n      deleteTargetAndNext = true;\n    }\n  } else {\n    if (cobjIsRoot) {\n      const hasChildReplies = REPLY_ROOTS.get(cidToDelete);\n      if (!hasChildReplies) {\n        deleteTarget = true;\n        const hasNext = NEXT.get(cidToDelete);\n        if (hasNext)\n          relinkNext = true;\n      } else\n        markDeleted = true;\n    } else {\n      const hasNext = NEXT.get(cidToDelete);\n      if (hasNext)\n        markDeleted = true;\n      else\n        deleteTarget = true;\n    }\n  }\n  if (deleteRootAndChildren) {\n    if (DBG2)\n      console.log(`deleteRootAndChildren`);\n    const childThreadIds = [];\n    COMMENTS.forEach((cobj) => {\n      if (cobj.comment_id_parent === cidToDelete)\n        childThreadIds.push(cobj.comment_id);\n    });\n    childThreadIds.forEach((cid) => {\n      COMMENTS.delete(cid);\n      queuedActions.push({ commentID: cid });\n    });\n  }\n  if (deleteTargetAndNext) {\n    if (DBG2)\n      console.log(`deleteTargetAndNext`);\n    const nextIds = m_GetNexts(cidToDelete);\n    nextIds.forEach((cid) => {\n      COMMENTS.delete(cid);\n      queuedActions.push({ commentID: cid });\n    });\n  }\n  if (relinkNext) {\n    if (DBG2)\n      console.log(`relinkNext`);\n    if (!cobjIsRoot)\n      throw new Error(\n        `relinkNext a non-root comment are you sure?  Usually we don't relink! ${cidToDelete}`\n      );\n    const nextCid = NEXT.get(cidToDelete);\n    const nextCobj = COMMENTS.get(nextCid);\n    const prev = COMMENTS.get(cobjToDelete.comment_id_previous);\n    if (nextCobj) {\n      nextCobj.comment_id_previous = prev ? prev.comment_id : \"\";\n      COMMENTS.set(nextCobj.comment_id, nextCobj);\n      queuedActions.push({ comment: nextCobj });\n    }\n  }\n  if (deleteTarget || deleteTargetAndNext || deleteRootAndChildren) {\n    if (DBG2)\n      console.log(\"deleteTarget or Root\", cidToDelete);\n    COMMENTS.delete(cidToDelete);\n    queuedActions.push({ commentID: cidToDelete });\n  } else if (markDeleted) {\n    if (DBG2)\n      console.log(\"markDeleted\", cidToDelete);\n    cobjToDelete.comment_type = DEFAULT_CommentTypes[0].id;\n    cobjToDelete.comment_isMarkedDeleted = true;\n    COMMENTS.set(cobjToDelete.comment_id, cobjToDelete);\n    queuedActions.push({ comment: cobjToDelete });\n  }\n  let rootId;\n  if (cobjIsRoot)\n    rootId = comment_id;\n  else\n    rootId = cobjToDelete.comment_id_parent;\n  if (m_AllAreMarkedDeleted(rootId)) {\n    if (DBG2)\n      console.log(\"delete all!\");\n    const rootCobj = COMMENTS.get(rootId);\n    if (rootCobj) {\n      const nextCid = NEXT.get(rootId);\n      const nextCobj = COMMENTS.get(nextCid);\n      const prev = COMMENTS.get(rootCobj.comment_id_previous);\n      if (nextCobj) {\n        nextCobj.comment_id_previous = prev ? prev.comment_id : \"\";\n        COMMENTS.set(nextCobj.comment_id, nextCobj);\n        queuedActions.push({ comment: nextCobj });\n      }\n    }\n    const replyIds = m_GetReplies(rootId);\n    replyIds.forEach((cid) => {\n      if (COMMENTS.has(cid)) {\n        COMMENTS.delete(cid);\n        queuedActions.push({ commentID: cid });\n      }\n    });\n    if (COMMENTS.has(rootId)) {\n      COMMENTS.delete(rootId);\n      queuedActions.push({ commentID: rootId });\n    }\n  }\n  if (!cobjIsRoot) {\n    const rootId2 = cobjToDelete.comment_id_parent;\n    const replyIds = m_GetReplies(rootId2).reverse();\n    for (let i = 0; i < replyIds.length; i++) {\n      const cid = replyIds[i];\n      const cobj = COMMENTS.get(cid);\n      if (cobj && cobj.comment_isMarkedDeleted) {\n        COMMENTS.delete(cid);\n        queuedActions.push({ commentID: cid });\n      } else if (cobj && !cobj.comment_isMarkedDelted) {\n        break;\n      }\n    }\n  }\n  m_DeriveValues();\n  return queuedActions;\n}\nfunction RemoveAllCommentsForCref(parms) {\n  const { collection_ref } = parms;\n  const queuedActions = [];\n  const cids = COMMENTS.forEach((cobj) => {\n    if (cobj.collection_ref === collection_ref) {\n      COMMENTS.delete(cobj.comment_id);\n      queuedActions.push({ commentID: cobj.comment_id });\n    }\n  });\n  m_DeriveValues();\n  return queuedActions;\n}\nfunction m_AllAreMarkedDeleted(rootCommentId) {\n  const allCommentIdsInThread = [rootCommentId, ...m_GetReplies(rootCommentId)];\n  const allCommentsInThread = allCommentIdsInThread.map((cid) => COMMENTS.get(cid));\n  let allAreMarkedDeleted = true;\n  allCommentsInThread.forEach((cobj) => {\n    if (!cobj)\n      return;\n    if (!cobj.comment_isMarkedDeleted)\n      allAreMarkedDeleted = false;\n  });\n  return allAreMarkedDeleted;\n}\nfunction HandleRemovedComments(comment_ids) {\n  comment_ids.forEach((comment_id) => {\n    if (DBG2)\n      console.log(\"...removing\", comment_id);\n    COMMENTS.delete(comment_id);\n  });\n  console.log(\"...remaining COMMENTS\", COMMENTS);\n  m_DeriveValues();\n}\nfunction MarkCommentRead(cid, uid) {\n  const readby = READBY.get(cid) || [];\n  if (!readby.includes(uid))\n    readby.push(uid);\n  READBY.set(cid, readby);\n}\nfunction MarkCommentUnread(cid, uid) {\n  const readby = READBY.get(cid) || [];\n  const updatedReadby = readby.filter((readByUid) => readByUid !== uid);\n  READBY.set(cid, updatedReadby);\n}\nfunction IsMarkedRead(cid, uid) {\n  const readby = READBY.get(cid) || [];\n  return readby.includes(uid);\n}\nfunction IsMarkedDeleted(cid) {\n  return COMMENTS.get(cid).comment_isMarkedDeleted;\n}\nfunction m_GetNexts(cid) {\n  const results = [];\n  const nextId = NEXT.get(cid);\n  if (nextId)\n    results.push(nextId, ...m_GetNexts(nextId));\n  return results;\n}\nfunction m_GetReplies(rootCid) {\n  const results = [];\n  const replyRootId = REPLY_ROOTS.get(rootCid);\n  if (replyRootId)\n    results.push(replyRootId, ...m_GetNexts(replyRootId));\n  return results;\n}\nfunction m_GetRepliesAndNext(cid) {\n  const results = [];\n  const reply_root_id = REPLY_ROOTS.get(cid);\n  if (reply_root_id) {\n    results.push(reply_root_id, ...m_GetRepliesAndNext(reply_root_id));\n  }\n  const nextId = NEXT.get(cid);\n  if (nextId) {\n    results.push(nextId, ...m_GetRepliesAndNext(nextId));\n  }\n  return results;\n}\nfunction GetThreadedCommentIds(cref) {\n  const all_comments_ids = [];\n  const rootId = ROOTS.get(cref);\n  if (rootId === void 0)\n    return [];\n  all_comments_ids.push(rootId, ...m_GetRepliesAndNext(rootId));\n  return all_comments_ids;\n}\nif (DBG2)\n  console.log(\"GetThreadedView\", GetThreadedCommentIds(\"1\"));\nif (DBG2)\n  console.log(\"GetThreadedView\", GetThreadedCommentIds(\"2\"));\nfunction GetThreadedCommentData(cref) {\n  const threaded_comments_ids = GetThreadedCommentIds(cref);\n  return threaded_comments_ids.map((cid) => COMMENTS.get(cid));\n}\nfunction GetReadby(cid) {\n  return READBY.get(cid);\n}\nfunction GetCrefs() {\n  return [...ROOTS.keys()];\n}\nvar dc_comment_default = {\n  Init,\n  // DB\n  LoadDB,\n  // USERS\n  GetUsers,\n  GetUser,\n  GetUserName,\n  GetCurrentUser,\n  // COMMENT TYPES\n  GetCommentTypes,\n  GetCommentType,\n  // COMMENTS\n  GetComments,\n  GetComment,\n  AddComment,\n  UpdateComment,\n  HandleUpdatedComments,\n  RemoveComment,\n  RemoveAllCommentsForCref,\n  HandleRemovedComments,\n  MarkCommentRead,\n  MarkCommentUnread,\n  IsMarkedRead,\n  IsMarkedDeleted,\n  GetThreadedCommentIds,\n  GetThreadedCommentData,\n  // GetThreadedCommentDataForRoot,\n  // READBY\n  GetReadby,\n  // ROOTS\n  GetCrefs\n};\n\n// _ur_addons/comment/ac-comment.ts\nvar DBG3 = true;\nvar COMMENTCOLLECTION = /* @__PURE__ */ new Map();\nvar COMMENTUISTATE = /* @__PURE__ */ new Map();\nvar OPENCOMMENTS = /* @__PURE__ */ new Map();\nvar COMMENTS_BEING_EDITED = /* @__PURE__ */ new Map();\nvar COMMENTVOBJS = /* @__PURE__ */ new Map();\nfunction Init2() {\n  if (DBG3)\n    console.log(\"ac-comments Init\");\n  dc_comment_default.Init();\n}\nfunction LoadDB2(data) {\n  dc_comment_default.LoadDB(data);\n}\nfunction GetDateString(ms) {\n  return new Date(ms).toLocaleString();\n}\nfunction GetCommentCollections() {\n  return COMMENTCOLLECTION;\n}\nfunction GetCommentCollection(cref) {\n  const collection = COMMENTCOLLECTION.get(cref);\n  return collection;\n}\nfunction UpdateCommentUIState(data) {\n  if (!data.uiref)\n    throw new Error('UpdateCommentUIState \"uiref\" must be defined!');\n  COMMENTUISTATE.set(data.uiref, { cref: data.cref, isOpen: data.isOpen });\n  OPENCOMMENTS.set(data.cref, data.uiref);\n}\nfunction CloseCommentCollection(uiref, cref, uid) {\n  COMMENTUISTATE.set(uiref, { cref, isOpen: false });\n  OPENCOMMENTS.set(cref, void 0);\n  MarkRead(cref, uid);\n  DeriveThreadedViewObjects(cref, uid);\n}\nfunction MarkRead(cref, uid) {\n  const commentVObjs = COMMENTVOBJS.get(cref);\n  commentVObjs.forEach((c) => dc_comment_default.MarkCommentRead(c.comment_id, uid));\n}\nfunction GetCommentStats(uid) {\n  let countRepliesToMe = 0;\n  let countUnread = 0;\n  DeriveAllThreadedViewObjects(uid);\n  const crefs = dc_comment_default.GetCrefs();\n  let rootCidsWithRepliesToMe = [];\n  crefs.forEach((cref) => {\n    const cvobjs = COMMENTVOBJS.get(cref);\n    cvobjs.find((cvobj) => {\n      const comment = dc_comment_default.GetComment(cvobj.comment_id);\n      if (comment.commenter_id === uid && comment.comment_id_parent !== \"\")\n        rootCidsWithRepliesToMe.push(comment.comment_id_parent);\n    });\n  });\n  COMMENTVOBJS.forEach((cvobjs) => {\n    cvobjs.forEach((cvobj) => {\n      if (!cvobj.isMarkedRead) {\n        countUnread++;\n        const comment = dc_comment_default.GetComment(cvobj.comment_id);\n        if (rootCidsWithRepliesToMe.includes(comment.comment_id_parent)) {\n          cvobj.isReplyToMe = true;\n          countRepliesToMe++;\n        }\n      }\n    });\n  });\n  return { countRepliesToMe, countUnread };\n}\nfunction GetCommentUIState(uiref) {\n  return COMMENTUISTATE.get(uiref);\n}\nfunction GetOpenComments(cref) {\n  return OPENCOMMENTS.get(cref);\n}\nfunction m_RegisterCommentBeingEdited(cid) {\n  COMMENTS_BEING_EDITED.set(cid, cid);\n}\nfunction m_DeRegisterCommentBeingEdited(cid) {\n  COMMENTS_BEING_EDITED.delete(cid);\n}\nfunction GetCommentBeingEdited(cid) {\n  return COMMENTS_BEING_EDITED.get(cid);\n}\nfunction GetUnreadRepliesToMe() {\n  const comments = [];\n  COMMENTVOBJS.forEach((cvobjs) => {\n    cvobjs.forEach((cvobj) => {\n      if (cvobj.isReplyToMe)\n        comments.push(dc_comment_default.GetComment(cvobj.comment_id));\n    });\n  });\n  return comments;\n}\nfunction GetUnreadComments() {\n  const comments = [];\n  COMMENTVOBJS.forEach((cvobjs) => {\n    cvobjs.forEach((cvobj) => {\n      if (!cvobj.isMarkedRead)\n        comments.push(dc_comment_default.GetComment(cvobj.comment_id));\n    });\n  });\n  return comments;\n}\nfunction DeriveAllThreadedViewObjects(uid) {\n  const crefs = dc_comment_default.GetCrefs();\n  crefs.forEach((cref) => DeriveThreadedViewObjects(cref, uid));\n}\nfunction DeriveThreadedViewObjects(cref, uid) {\n  if (cref === void 0)\n    throw new Error(`m_DeriveThreadedViewObjects cref: \"${cref}\" must be defined!`);\n  const commentVObjs = [];\n  const threadIds = dc_comment_default.GetThreadedCommentIds(cref);\n  threadIds.forEach((cid) => {\n    const comment = dc_comment_default.GetComment(cid);\n    if (comment === void 0)\n      console.error(\"GetThreadedViewObjects for cid not found\", cid, \"in\", threadIds);\n    const level = comment.comment_id_parent === \"\" ? 0 : 1;\n    commentVObjs.push({\n      comment_id: cid,\n      createtime_string: GetDateString(comment.comment_createtime),\n      modifytime_string: comment.comment_modifytime ? GetDateString(comment.comment_modifytime) : \"\",\n      level,\n      isSelected: false,\n      isBeingEdited: false,\n      isEditable: false,\n      isMarkedRead: dc_comment_default.IsMarkedRead(cid, uid),\n      allowReply: void 0\n      // will be defined next\n    });\n  });\n  const reversedCommentVObjs = commentVObjs.reverse();\n  const commentReplyVObj = [];\n  let prevLevel = -1;\n  reversedCommentVObjs.forEach((cvobj) => {\n    if (cvobj.level === 0 && cvobj.level >= prevLevel || // is top level without a reply thread\n    cvobj.level > prevLevel)\n      cvobj.allowReply = true;\n    commentReplyVObj.push(cvobj);\n    prevLevel = cvobj.level;\n  });\n  COMMENTVOBJS.set(cref, commentReplyVObj.reverse());\n  const ccol = COMMENTCOLLECTION.get(cref) || { collection_ref: cref };\n  const hasReadComments = commentReplyVObj.length > 0;\n  let hasUnreadComments = false;\n  commentReplyVObj.forEach((c) => {\n    if (!c.isMarkedRead)\n      hasUnreadComments = true;\n  });\n  ccol.hasUnreadComments = hasUnreadComments;\n  ccol.hasReadComments = hasReadComments;\n  COMMENTCOLLECTION.set(cref, ccol);\n  return commentReplyVObj;\n}\nfunction GetThreadedViewObjects(cref, uid) {\n  const commentVObjs = COMMENTVOBJS.get(cref);\n  return commentVObjs === void 0 ? DeriveThreadedViewObjects(cref, uid) : commentVObjs;\n}\nfunction GetThreadedViewObjectsCount(cref, uid) {\n  return GetThreadedViewObjects(cref, uid).length;\n}\nfunction GetCOMMENTVOBJS() {\n  return COMMENTVOBJS;\n}\nfunction GetCommentVObj(cref, cid) {\n  const thread = COMMENTVOBJS.get(cref);\n  const cvobj = thread.find((c) => c.comment_id === cid);\n  return cvobj;\n}\nfunction AddComment2(data) {\n  if (data.cref === void 0)\n    throw new Error(\"Comments must have a collection ref!\");\n  const comment = dc_comment_default.AddComment(data);\n  DeriveThreadedViewObjects(data.cref, data.commenter_id);\n  let commentVObjs = GetThreadedViewObjects(data.cref, data.commenter_id);\n  const cvobj = GetCommentVObj(comment.collection_ref, comment.comment_id);\n  if (cvobj === void 0)\n    console.error(\n      \"ac-comment:Could not find CommentVObj\",\n      comment.collection_ref,\n      comment.comment_id,\n      COMMENTVOBJS\n    );\n  cvobj.isBeingEdited = true;\n  m_RegisterCommentBeingEdited(comment.comment_id);\n  commentVObjs = commentVObjs.map(\n    (c) => c.comment_id === cvobj.comment_id ? cvobj : c\n  );\n  COMMENTVOBJS.set(data.cref, commentVObjs);\n  let ccol = GetCommentCollection(data.cref);\n  ccol.isOpen = true;\n  COMMENTCOLLECTION.set(data.cref, ccol);\n  return comment;\n}\nfunction UpdateComment2(cobj, uid) {\n  if (cobj.collection_ref === void 0)\n    throw new Error(\"UpdateComment cref is undefined\", cobj);\n  dc_comment_default.UpdateComment(cobj);\n  DeriveThreadedViewObjects(cobj.collection_ref, uid);\n  let commentVObjs = GetThreadedViewObjects(cobj.collection_ref, uid);\n  const cvobj = GetCommentVObj(cobj.collection_ref, cobj.comment_id);\n  if (cvobj === void 0)\n    throw new Error(\n      `ac-comment.UpdateComment could not find cobj ${cobj.comment_id}.  Maybe it hasn't been created yet? ${COMMENTVOBJS}`\n    );\n  cvobj.isMarkedRead = false;\n  dc_comment_default.MarkCommentUnread(cvobj.comment_id, uid);\n  cvobj.isBeingEdited = false;\n  m_DeRegisterCommentBeingEdited(cobj.comment_id);\n  cvobj.modifytime_string = GetDateString(cobj.comment_modifytime);\n  commentVObjs = commentVObjs.map(\n    (c) => c.comment_id === cvobj.comment_id ? cvobj : c\n  );\n  COMMENTVOBJS.set(cobj.collection_ref, commentVObjs);\n}\nfunction HandleUpdatedComments2(comments) {\n  dc_comment_default.HandleUpdatedComments(comments);\n}\nfunction RemoveComment2(parms) {\n  if (parms.collection_ref === void 0)\n    throw new Error(\"RemoveComment collection_ref is undefined\", parms);\n  const queuedActions = dc_comment_default.RemoveComment(parms);\n  DeriveThreadedViewObjects(parms.collection_ref, parms.uid);\n  queuedActions.push({ collection_ref: parms.collection_ref });\n  return queuedActions;\n}\nfunction RemoveAllCommentsForCref2(parms) {\n  if (parms.collection_ref === void 0)\n    throw new Error(\"RemoveAllCommentsForCref collection_ref is undefined\", parms);\n  const queuedActions = dc_comment_default.RemoveAllCommentsForCref(parms);\n  DeriveThreadedViewObjects(parms.collection_ref, parms.uid);\n  queuedActions.push({ collection_ref: parms.collection_ref });\n  return queuedActions;\n}\nfunction HandleRemovedComments2(comment_ids) {\n  dc_comment_default.HandleRemovedComments(comment_ids);\n}\nfunction GetUserName2(uid) {\n  return dc_comment_default.GetUserName(uid);\n}\nfunction GetCommentTypes2() {\n  return dc_comment_default.GetCommentTypes();\n}\nfunction GetComment2(cid) {\n  return dc_comment_default.GetComment(cid);\n}\nfunction GetReadby2(cid) {\n  return dc_comment_default.GetReadby(cid);\n}\nfunction GetCrefs2() {\n  return dc_comment_default.GetCrefs();\n}\n\n// _ur_addons/@addons-client.ts\nvar { ConsoleStyler } = client_esm_exports;\nvar PF = ConsoleStyler(\"UR/ADD\", \"TagPink\");\nvar CLASS2 = {\n  NetEndpoint,\n  NetSocket,\n  NetPacket\n};\nfunction AddonClientTest() {\n  console.log(...PF(\"System Integration of new URSYS addon successful!\"));\n}\n//# sourceMappingURL=addons-client-cjs.js.map\n  })();\n});"]}