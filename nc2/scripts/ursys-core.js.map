{"version":3,"sources":["node_modules/@ursys/core/_dist/client-cjs.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"public/scripts/ursys-core.js","sourcesContent":["\nrequire.register(\"@ursys/core/_dist/client-cjs.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"@ursys/core\");\n  (function() {\n    var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// _ur/common/declare-console.js\nvar require_declare_console = __commonJS({\n  \"_ur/common/declare-console.js\"(exports, module2) {\n    var TERM_COLORS = {\n      // TOUT = makeTerminalOut(str); TOUT('hi')\n      Reset: \"\\x1B[0m\",\n      Bright: \"\\x1B[1m\",\n      Dim: \"\\x1B[2m\",\n      Underscore: \"\\x1B[4m\",\n      Blink: \"\\x1B[5m\",\n      Reverse: \"\\x1B[7m\",\n      Hidden: \"\\x1B[8m\",\n      //\n      Black: \"\\x1B[30m\",\n      White: \"\\x1B[37m\",\n      Red: \"\\x1B[31m\",\n      Orange: \"\\x1B[38;5;202m\",\n      Yellow: \"\\x1B[33m\",\n      Green: \"\\x1B[32m\",\n      Cyan: \"\\x1B[36m\",\n      Blue: \"\\x1B[34m\",\n      Purple: \"\\x1B[35m\",\n      //\n      BgBlack: \"\\x1B[40m\",\n      BgGray: \"\\x1B[100m\",\n      BgWhite: \"\\x1B[47m\",\n      BgRed: \"\\x1B[41m\",\n      BgOrange: \"\\x1B[48;5;202m\",\n      BgYellow: \"\\x1B[43m\",\n      BgCyan: \"\\x1B[46m\",\n      BgGreen: \"\\x1B[42m\",\n      BgBlue: \"\\x1B[44m\",\n      BgPurple: \"\\x1B[45m\",\n      BgPink: \"\\x1B[105m\",\n      // FORMATS\n      TagBlack: \"\\x1B[30;1m\",\n      TagWhite: \"\\x1B[37;1m\",\n      TagRed: \"\\x1B[41;37m\",\n      TagOrange: \"\\x1B[43;37m\",\n      TagYellow: \"\\x1B[43;30m\",\n      TagGreen: \"\\x1B[42;30m\",\n      TagCyan: \"\\x1B[46;37m\",\n      TagBlue: \"\\x1B[44;37m\",\n      TagPurple: \"\\x1B[45;37m\",\n      TagPink: \"\\x1B[105;1m\",\n      TagGray: \"\\x1B[100;37m\",\n      TagNull: \"\\x1B[2;37m\"\n    };\n    var CSS_COMMON = \"padding:3px 5px;border-radius:2px;\";\n    var CSS_COLORS = {\n      Reset: \"color:auto;background-color:auto\",\n      // COLOR FOREGROUND\n      Black: \"color:black\",\n      White: \"color:white\",\n      Red: \"color:red\",\n      Orange: \"color:orange\",\n      Yellow: \"color:orange\",\n      Green: \"color:green\",\n      Cyan: \"color:cyan\",\n      Blue: \"color:blue\",\n      Magenta: \"color:magenta\",\n      Pink: \"color:pink\",\n      // COLOR BACKGROUND\n      TagRed: `color:#000;background-color:#f66;${CSS_COMMON}`,\n      TagOrange: `color:#000;background-color:#fa4;${CSS_COMMON}`,\n      TagYellow: `color:#000;background-color:#fd4;${CSS_COMMON}`,\n      TagGreen: `color:#000;background-color:#5c8;${CSS_COMMON}`,\n      TagCyan: `color:#000;background-color:#2dd;${CSS_COMMON}`,\n      TagBlue: `color:#000;background-color:#2bf;${CSS_COMMON}`,\n      TagPurple: `color:#000;background-color:#b6f;${CSS_COMMON}`,\n      TagPink: `color:#000;background-color:#f9f;${CSS_COMMON}`,\n      TagGray: `color:#fff;background-color:#999;${CSS_COMMON}`,\n      TagNull: `color:#999;border:1px solid #ddd;${CSS_COMMON}`,\n      // COLOR BACKGROUND DARK (BROWSER ONLY)\n      TagDkRed: `color:white;background-color:maroon;${CSS_COMMON}`,\n      TagDkOrange: `color:white;background-color:burntorange;${CSS_COMMON}`,\n      TagDkYellow: `color:white;background-color:brown;${CSS_COMMON}`,\n      TagDkGreen: `color:white;background-color:forestgreen;${CSS_COMMON}`,\n      TagDkCyan: `color:white;background-color:cerulean;${CSS_COMMON}`,\n      TagDkBlue: `color:white;background-color:darkblue;${CSS_COMMON}`,\n      TagDkPurple: `color:white;background-color:indigo;${CSS_COMMON}`,\n      TagDkPink: `color:white;background-color:fuchsia;${CSS_COMMON}`\n    };\n    TERM_COLORS.TagBuild = TERM_COLORS.TagGray;\n    TERM_COLORS.TagError = TERM_COLORS.TagRed;\n    TERM_COLORS.TagAlert = TERM_COLORS.TagOrange;\n    TERM_COLORS.TagTest = TERM_COLORS.TagRed;\n    TERM_COLORS.TagSystem = TERM_COLORS.TagGray;\n    TERM_COLORS.TagServer = TERM_COLORS.TagGray;\n    TERM_COLORS.TagDatabase = TERM_COLORS.TagCyan;\n    TERM_COLORS.TagNetwork = TERM_COLORS.TagCyan;\n    TERM_COLORS.TagUR = TERM_COLORS.TagBlue;\n    TERM_COLORS.TagURNET = TERM_COLORS.TagBlue;\n    TERM_COLORS.TagURMOD = TERM_COLORS.TagBlue;\n    TERM_COLORS.TagAppMain = TERM_COLORS.TagGreen;\n    TERM_COLORS.TagAppModule = TERM_COLORS.TagGreen;\n    TERM_COLORS.TagAppState = TERM_COLORS.TagGreen;\n    TERM_COLORS.TagAppCore = TERM_COLORS.TagGreen;\n    TERM_COLORS.TagDataCore = TERM_COLORS.TagGreen;\n    TERM_COLORS.TagUI = TERM_COLORS.TagPurple;\n    TERM_COLORS.TagPhase = TERM_COLORS.TagPink;\n    TERM_COLORS.TagEvent = TERM_COLORS.TagPink;\n    TERM_COLORS.TagStream = TERM_COLORS.TagPink;\n    CSS_COLORS.TagDebug = `color:#fff;background-color:IndianRed;${CSS_COMMON}`;\n    CSS_COLORS.TagWarning = `color:#fff;background:linear-gradient(\n  -45deg,\n  rgb(29,161,242),\n  rgb(184,107,107),\n  rgb(76,158,135)\n);${CSS_COMMON}`;\n    CSS_COLORS.TagTest = CSS_COLORS.TagRed;\n    CSS_COLORS.TagSystem = CSS_COLORS.TagGray;\n    CSS_COLORS.TagServer = CSS_COLORS.TagGray;\n    CSS_COLORS.TagDatabase = CSS_COLORS.TagCyan;\n    CSS_COLORS.TagNetwork = CSS_COLORS.TagCyan;\n    CSS_COLORS.TagUR = `color:CornflowerBlue;border:1px solid CornflowerBlue;${CSS_COMMON}`;\n    CSS_COLORS.TagURNET = `color:#fff;background-color:MediumSlateBlue;${CSS_COMMON}`;\n    CSS_COLORS.TagURMOD = `color:#fff;background:linear-gradient(\n  -45deg,\n  CornflowerBlue 0%,\n  LightSkyBlue 25%,\n  RoyalBlue 100%\n);${CSS_COMMON}`;\n    CSS_COLORS.TagAppMain = CSS_COLORS.TagGreen;\n    CSS_COLORS.TagAppModule = CSS_COLORS.TagGreen;\n    CSS_COLORS.TagAppState = `color:#fff;background-color:Navy;${CSS_COMMON}`;\n    CSS_COLORS.TagUI = CSS_COLORS.TagDkOrange;\n    CSS_COLORS.TagEvent = CSS_COLORS.TagDkOrange;\n    CSS_COLORS.TagStream = CSS_COLORS.TagDkOrange;\n    CSS_COLORS.TagPhase = `color:#fff;background-color:MediumVioletRed;${CSS_COMMON}`;\n    module2.exports = {\n      TERM_COLORS,\n      CSS_COLORS\n    };\n  }\n});\n\n// _ur/common/util-prompts.js\nvar require_util_prompts = __commonJS({\n  \"_ur/common/util-prompts.js\"(exports, module2) {\n    var IS_NODE = typeof window === \"undefined\";\n    var IS_MOBILE = !IS_NODE && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n      navigator.userAgent\n    );\n    var D_CONSOLE = require_declare_console();\n    var { TERM_COLORS, CSS_COLORS } = D_CONSOLE;\n    var DEFAULT_PADDING = IS_NODE ? 10 : 8;\n    var DEFAULT_SPACE = IS_NODE ? \" \".padStart(DEFAULT_PADDING, \" \") : \" \".padStart(DEFAULT_PADDING + 4, \" \");\n    var DEFAULT_COLOR = \"TagNull\";\n    var HTCONSOLES = {};\n    var SHOW = true;\n    var PROMPT_DICT = {\n      // URSYS-RELATED MODULES\n      \"UR\": [SHOW, \"TagRed\"],\n      // SERVERS\n      \"APPSRV\": [SHOW, \"Yellow\"],\n      \"GEMSRV\": [SHOW, \"Yellow\"],\n      // SPECIAL\n      \"-\": [SHOW, \"TagNull\"]\n    };\n    function padString(str, padding = DEFAULT_PADDING) {\n      let len = str.length;\n      const nbsp = String.fromCharCode(160);\n      if (IS_NODE)\n        return `${str.padEnd(padding, \" \")}`;\n      if (padding === 0)\n        return `${str}`;\n      if (len >= padding)\n        str = str.substr(0, padding);\n      else\n        str = str.padEnd(padding, nbsp);\n      return `${str}`;\n    }\n    function m_SetPromptColors(match, color = DEFAULT_COLOR) {\n      if (typeof match !== \"string\")\n        throw Error(\"match prompt must be string\");\n      match = match.trim();\n      if (match === \"\")\n        throw Error(\"match prompt cannot be empty\");\n      let colorTable = IS_NODE ? TERM_COLORS : CSS_COLORS;\n      let validColor = false;\n      validColor = colorTable[color] !== void 0;\n      if (!validColor)\n        colorTable = IS_NODE ? CSS_COLORS : TERM_COLORS;\n      validColor = colorTable[color] !== void 0;\n      if (!validColor)\n        throw Error(`prompt color ${color} is not defined in either table`);\n      PROMPT_DICT[match] = [true, color];\n      return colorTable;\n    }\n    function m_GetEnvColor(prompt, tagColor) {\n      const colorTable = m_SetPromptColors(prompt, tagColor);\n      const [dbg_mode, defcol] = PROMPT_DICT[prompt.trim()] || [SHOW, DEFAULT_COLOR];\n      const ucolor = colorTable[tagColor];\n      const dcolor = colorTable[defcol];\n      const color = ucolor || dcolor;\n      const reset = colorTable.Reset;\n      return [dbg_mode, color, reset];\n    }\n    function m_MakeColorArray(prompt, colorName) {\n      const [dbg, color, reset] = m_GetEnvColor(prompt, colorName);\n      if (!(dbg || IS_NODE))\n        return [];\n      return IS_NODE ? [`${color}${padString(prompt)}${reset}   `] : [`%c${padString(prompt)}%c `, color, reset];\n    }\n    function m_MakeColorPromptFunction(prompt, colorName, opt = {}) {\n      const textColor = opt.color || \"Reset\";\n      const dim = opt.dim || false;\n      return IS_NODE ? (str, ...args) => {\n        if (args === void 0)\n          args = \"\";\n        let TAG = TERM_COLORS[colorName];\n        let TEXT2 = TERM_COLORS[textColor];\n        let RST = TERM_COLORS.Reset;\n        let PR2 = padString(prompt);\n        if (dim)\n          TEXT2 += TERM_COLORS.Dim;\n        console.log(`${RST}${TAG}${PR2}${RST}${TEXT2}    ${str}`, ...args);\n      } : (str, ...args) => {\n        if (args === void 0)\n          args = \"\";\n        let TEXT2 = TERM_COLORS[textColor];\n        let RST = CSS_COLORS.Reset;\n        let PR2 = padString(prompt);\n        console.log(`%c${PR2}%c%c ${str}`, RST, TEXT2, ...args);\n      };\n    }\n    function m_GetDivText(id) {\n      const el = document.getElementById(id);\n      if (!el) {\n        console.log(`GetDivText: element ${id} does not exist`);\n        return void 0;\n      }\n      const text = el.textContent;\n      if (text === void 0) {\n        console.log(`HTMLTextOut: element ${id} does not have textContent`);\n        return {};\n      }\n      el.style.whiteSpace = \"pre\";\n      el.style.fontFamily = \"monospace\";\n      return { element: el, text };\n    }\n    function m_HTMLTextJumpRow(row, lineBuffer, id) {\n      const { element, text } = m_GetDivText(id);\n      if (text === void 0)\n        return lineBuffer;\n      if (lineBuffer.length === 0) {\n        console.log(`initializing linebuffer from element id='${id}'`);\n        lineBuffer = text.split(\"\\n\");\n      }\n      if (row > lineBuffer.length - 1) {\n        const count = row + 1 - lineBuffer.length;\n        for (let i = count; i > 0; i--)\n          lineBuffer.push(\"\");\n      }\n      return lineBuffer;\n    }\n    function m_HTMLTextPrint(str = \"\", lineBuffer, id) {\n      const { element, text } = m_GetDivText(id);\n      if (!text)\n        return lineBuffer;\n      lineBuffer.push(str);\n      element.textContent = lineBuffer.join(\"\\n\");\n      return lineBuffer;\n    }\n    function m_HTMLTextPlot(str = \"\", lineBuffer, id, row = 0, col = 0) {\n      const { element, text } = m_GetDivText(id);\n      if (!element)\n        return lineBuffer;\n      if (text === void 0) {\n        console.log(`HTMLTextOut: element ${id} does not have textContent`);\n        return lineBuffer;\n      }\n      lineBuffer = m_HTMLTextJumpRow(row, lineBuffer, id);\n      let line = lineBuffer[row];\n      if (line === void 0) {\n        console.log(`HTMLTextOut: unexpected line error for line ${row}`);\n        return lineBuffer;\n      }\n      if (col + str.length > line.length + str.length) {\n        for (let i = 0; i < col + str.length - line.length; i++)\n          line += \" \";\n      }\n      let p1 = line.substr(0, col);\n      let p3 = line.substr(col + str.length, line.length - (col + str.length));\n      lineBuffer[row] = `${p1}${str}${p3}`;\n      element.textContent = lineBuffer.join(\"\\n\");\n      return lineBuffer;\n    }\n    function makeStyleFormatter2(prompt, tagColor) {\n      if (prompt.startsWith(\"UR\") && tagColor === void 0)\n        tagColor = \"TagUR\";\n      let outArray = m_MakeColorArray(prompt, tagColor);\n      if (outArray.length === 0)\n        return () => [];\n      if (IS_MOBILE)\n        outArray = [`${prompt}:`];\n      const f = (str, ...args) => [...outArray, str, ...args];\n      f._ = `\n${DEFAULT_SPACE}`;\n      return f;\n    }\n    function makeErrorFormatter(pr = \"\") {\n      const bg = \"rgba(255,0,0,1)\";\n      const bga = \"rgba(255,0,0,0.15)\";\n      pr = `ERROR ${pr}`.trim();\n      return (str, ...args) => [\n        `%c${pr}%c${str}`,\n        `color:#fff;background-color:${bg};padding:3px 7px 3px 10px;border-radius:10px 0 0 10px;`,\n        `color:${bg};background-color:${bga};padding:3px 5px;`,\n        ...args\n      ];\n    }\n    function makeWarningFormatter(pr = \"\") {\n      const bg = \"rgba(255,150,0,1)\";\n      const bga = \"rgba(255,150,0,0.15)\";\n      pr = `WARN ${pr}`.trim();\n      return (str, ...args) => [\n        `%c${pr}%c${str}`,\n        `color:#fff;background-color:${bg};padding:3px 7px 3px 10px;border-radius:10px 0 0 10px;`,\n        `color:${bg};background-color:${bga};padding:3px 5px;`,\n        ...args\n      ];\n    }\n    function dbgPrint(pr, bg = \"MediumVioletRed\") {\n      return [\n        `%c${pr}%c`,\n        `color:#fff;background-color:${bg};padding:3px 10px;border-radius:10px;`,\n        \"color:auto;background-color:auto\"\n      ];\n    }\n    function colorTagString(str, tagColor) {\n      return m_MakeColorArray(str, tagColor);\n    }\n    function makeTerminalOut(prompt, tagColor = DEFAULT_COLOR) {\n      const wrap = m_MakeColorPromptFunction(prompt, tagColor);\n      wrap.warn = m_MakeColorPromptFunction(prompt, \"TagYellow\", { color: \"Yellow\" });\n      wrap.error = m_MakeColorPromptFunction(prompt, \"TagRed\", { color: \"Red\" });\n      wrap.fail = m_MakeColorPromptFunction(prompt, \"Red\", { color: \"Red\" });\n      wrap.pass = m_MakeColorPromptFunction(prompt, \"Green\", { color: \"Green\" });\n      wrap.info = m_MakeColorPromptFunction(prompt, \"TagGray\", { dim: true });\n      wrap.DIM = \"\\x1B[2m\";\n      wrap.BRI = \"\\x1B[1m\";\n      wrap.RST = \"\\x1B[0m\";\n      return wrap;\n    }\n    function makeHTMLConsole(divId, row = 0, col = 0) {\n      const ERP = makeStyleFormatter2(\"makeHTMLConsole\", \"Red\");\n      let buffer = [];\n      if (typeof divId !== \"string\")\n        throw Error(\"bad id\");\n      if (!document.getElementById(divId)) {\n        console.warn(...ERP(`id '${divId}' doesn't exist`));\n        return {\n          print: () => {\n          },\n          plot: () => {\n          },\n          clear: () => {\n          },\n          gotoRow: () => {\n          }\n        };\n      }\n      let hcon;\n      if (HTCONSOLES[divId]) {\n        hcon = HTCONSOLES[divId];\n      } else {\n        hcon = {\n          buffer: [],\n          plot: (str, y = row, x = col) => {\n            buffer = m_HTMLTextPlot(str, buffer, divId, y, x);\n          },\n          print: (str) => {\n            buffer = m_HTMLTextPrint(str, buffer, divId);\n          },\n          clear: (startRow = 0, endRow = buffer.length) => {\n            buffer.splice(startRow, endRow);\n          },\n          gotoRow: (row2) => {\n            buffer = m_HTMLTextJumpRow(row2, buffer, divId);\n          }\n        };\n        HTCONSOLES[divId] = hcon;\n      }\n      return hcon;\n    }\n    function printTagColors() {\n      const colortable = IS_NODE ? TERM_COLORS : CSS_COLORS;\n      const colors = Object.keys(colortable).filter((element) => element.includes(\"Tag\"));\n      const reset = colortable.Reset;\n      const out = \"dbg_colors\";\n      if (!IS_NODE)\n        console.groupCollapsed(out);\n      colors.forEach((key) => {\n        const color = colortable[key];\n        const items = IS_NODE ? [`${padString(out)} - (node) ${color}${key}${reset}`] : [`(browser) %c${key}%c`, color, reset];\n        console.log(...items);\n      });\n      if (!IS_NODE)\n        console.groupEnd();\n    }\n    module2.exports = {\n      TERM: TERM_COLORS,\n      CSS: CSS_COLORS,\n      padString,\n      makeStyleFormatter: makeStyleFormatter2,\n      makeErrorFormatter,\n      makeWarningFormatter,\n      dbgPrint,\n      makeTerminalOut,\n      makeHTMLConsole,\n      printTagColors,\n      colorTagString\n    };\n  }\n});\n\n// _ur/common/util-text.js\nvar require_util_text = __commonJS({\n  \"_ur/common/util-text.js\"(exports, module2) {\n    function PreprocessDataText(str) {\n      let normalizedStr = str.replace(/\\r\\n|\\r/g, \"\\n\");\n      normalizedStr = normalizedStr.split(\"\\n\").map((line) => line.replace(/\\s+$/, \"\")).map((line) => line.replace(/^\\s+/, \"\")).join(\"\\n\");\n      normalizedStr = normalizedStr.replace(/\\t/g, \"  \");\n      let lines = normalizedStr.split(\"\\n\");\n      const processDelimited = (line, delimiter) => {\n        let parts = line.split(delimiter);\n        for (let i = 0; i < parts.length; i++) {\n          parts[i] = parts[i].trim();\n          parts[i] = parts[i].replace(/\\s+/g, \" \");\n        }\n        return parts.join(delimiter);\n      };\n      for (let i = 0; i < lines.length; i++) {\n        lines[i] = processDelimited(lines[i], \",\", { preserve: true });\n        lines[i] = processDelimited(lines[i], \":\", { preserve: true });\n      }\n      normalizedStr = lines.join(\"\\n\").trim();\n      return normalizedStr + \"\\n\";\n    }\n    module2.exports = {\n      PreprocessDataText\n    };\n  }\n});\n\n// _ur/browser-client/@client.ts\nvar client_exports = {};\n__export(client_exports, {\n  CLASS: () => CLASS,\n  ClientTest: () => ClientTest,\n  ConsoleStyler: () => makeStyleFormatter,\n  PROMPTS: () => import_util_prompts.default,\n  StateMgr: () => class_state_mgr_default,\n  TEXT: () => import_util_text.default\n});\nmodule.exports = __toCommonJS(client_exports);\nvar import_util_prompts = __toESM(require_util_prompts());\nvar import_util_text = __toESM(require_util_text());\n\n// _ur/common/class-op-seq.ts\nvar OPSEQS = /* @__PURE__ */ new Map();\nfunction m_ValidateSeqName(sn) {\n  const fn = \"m_ValidateSeqName\";\n  const pcErr = \"name must be PascalCase string\";\n  if (sn === \"\")\n    throw Error(`${fn}: ${pcErr}`);\n  if (sn === void 0)\n    throw Error(`${fn}: ${pcErr}`);\n  if (typeof sn !== \"string\")\n    throw Error(`${fn}: ${pcErr}`);\n  if (sn !== sn[0].toUpperCase() + sn.slice(1))\n    throw Error(`${fn}: ${pcErr}`);\n  if (sn.trim() !== sn)\n    throw Error(`${fn}: name must not have leading/trailing spaces`);\n}\nfunction m_ValidateActiveSeq(seq) {\n  if (seq instanceof OpSequencer) {\n    if (seq._disposed)\n      throw Error(`sequencer ${seq.seqName} is disposed`);\n    else\n      return;\n  }\n  throw Error(\"not a sequence instance or undefined\");\n}\nfunction m_ValidateNodeName(nn) {\n  const fn = \"m_ValidateNodeName\";\n  if (nn === \"\")\n    throw Error(`${fn}: name must be lc string`);\n  if (nn === void 0)\n    throw Error(`${fn}: name must be lc string`);\n  if (typeof nn !== \"string\")\n    throw Error(`${fn}: name must be lc string`);\n  if (nn !== nn.toLowerCase())\n    throw Error(`${fn}: name must be lc`);\n  if (nn.trim() !== nn)\n    throw Error(`${fn}: name must not have leading/trailing spaces`);\n}\nvar OpSequencer = class _OpSequencer {\n  // true if disposed\n  constructor(seqName) {\n    __publicField(this, \"ops\");\n    // array of operations\n    __publicField(this, \"seqName\");\n    // sequencer name\n    __publicField(this, \"lastOp\");\n    // last operation\n    __publicField(this, \"currentOp\");\n    // current operation\n    __publicField(this, \"opIndex\");\n    // current operation index\n    __publicField(this, \"opsMap\");\n    // map opname to index in ops array\n    __publicField(this, \"subs\");\n    // map opname to set of subscribers\n    __publicField(this, \"_disposed\");\n    m_ValidateSeqName(seqName);\n    seqName = seqName.trim().toUpperCase();\n    if (OPSEQS.has(seqName)) {\n      console.warn(\n        `(not an error) '${seqName}' construction duplicate, returning existing instance`\n      );\n      return OPSEQS.get(seqName);\n    }\n    this.seqName = seqName;\n    this.ops = [];\n    this.opsMap = /* @__PURE__ */ new Map();\n    this.opIndex = -1;\n    this.currentOp = null;\n    this.lastOp = null;\n    this.subs = /* @__PURE__ */ new Map();\n    this._disposed = false;\n    OPSEQS.set(seqName, this);\n  }\n  /* --- add nodes --- */\n  /** given nodeName and a source TOpNode, add a clone of the source node to the sequencer */\n  addOp(name, data, opt) {\n    const fn = \"addOp\";\n    if (data === void 0)\n      throw Error(`${fn}: arg2 must be TOpNode`);\n    if (typeof name !== \"string\")\n      throw Error(`${fn}: arg1 must be name:string`);\n    if (typeof data._name === \"string\")\n      throw Error(`${fn}: node ${name} reused`);\n    if (data._index !== void 0)\n      throw Error(`${fn}: node ${name} reused`);\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(name);\n    if (this.opIndex !== -1)\n      throw Error(`${fn}: sequencer already started`);\n    if (this.hasOp(name))\n      throw Error(`${fn}: node '${name}' already exists`);\n    const index = this.ops.length;\n    this.opsMap.set(name, index);\n    const newData = { ...data };\n    if (opt == null ? void 0 : opt.mutable)\n      Object.freeze(newData);\n    const newNode = {\n      _opIndex: index,\n      _seqName: this.seqName,\n      _opName: name,\n      data: newData\n    };\n    this.ops.push(newNode);\n    return newNode;\n  }\n  deleteOp(name) {\n    const fn = \"deleteOp\";\n    console.error(`${fn}: not implemented by design`);\n  }\n  /* --- access operations --- */\n  data(key) {\n    m_ValidateActiveSeq(this);\n    if (typeof key === \"string\")\n      return this.currentOp.data[key];\n    return this.currentOp.data;\n  }\n  length() {\n    m_ValidateActiveSeq(this);\n    return this.ops.length;\n  }\n  /* --- sequencer operations --- */\n  start() {\n    const fn = \"start\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex !== -1)\n      throw Error(`${fn}: sequencer already started`);\n    if (this.ops.length === 0)\n      throw Error(`${fn}: no operations to run`);\n    this.opIndex = 0;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  current() {\n    const fn = \"current\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === -1)\n      throw Error(`${fn}: sequencer not started`);\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  stop() {\n    const fn = \"stop\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === -1)\n      throw Error(\"stop: sequencer not started\");\n    this.opIndex = -1;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  next() {\n    const fn = \"next\";\n    if (this.opIndex === -1)\n      return this.start();\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === this.ops.length - 1)\n      return void 0;\n    ++this.opIndex;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  previous() {\n    const fn = \"previous\";\n    m_ValidateActiveSeq(this);\n    if (this.opIndex === -1)\n      throw Error(`${fn}: sequencer not started`);\n    if (this.opIndex === 0)\n      return void 0;\n    --this.opIndex;\n    this._update();\n    this._notifyChange();\n    return this.ops[this.opIndex];\n  }\n  /* --- node events --- */\n  subscribe(opName, subf) {\n    const fn = \"onEnter\";\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(opName);\n    if (!this.hasOp(opName))\n      throw Error(`${fn}: node '${opName}' does not exist`);\n    if (!this.subs.has(opName))\n      this.subs.set(opName, /* @__PURE__ */ new Set());\n    this.subs.get(opName).add(subf);\n  }\n  unsubscribe(name, subf) {\n    const fn = \"onEnter\";\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(name);\n    if (!this.hasOp(name))\n      throw Error(`${fn}: node '${name}' does not exist`);\n    const subs = this.subs.get(name);\n    if (subs.has(subf))\n      subs.delete(subf);\n  }\n  _update() {\n    const fn = \"_update\";\n    m_ValidateActiveSeq(this);\n    this.lastOp = this.currentOp;\n    this.currentOp = this.ops[this.opIndex];\n  }\n  _notifyChange() {\n    const fn = \"_notifyChange\";\n    m_ValidateActiveSeq(this);\n    const subs = this.subs.get(this.currentOp._opName);\n    if (subs)\n      subs.forEach((subf) => subf(this.currentOp, this.lastOp, this));\n  }\n  /* --- node utilities --- */\n  hasOp(opName) {\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(opName);\n    return this.ops.some((op) => op._opName === opName);\n  }\n  matchOp(opName) {\n    const fn = \"matchOp\";\n    m_ValidateActiveSeq(this);\n    m_ValidateNodeName(opName);\n    if (!this.hasOp(opName))\n      throw Error(`${fn}: node '${opName}' does not exist`);\n    return opName === this.ops[this.opIndex]._opName;\n  }\n  /** remove all nodes and subscribers */\n  dispose() {\n    _OpSequencer.DeleteSequencer(this.seqName);\n  }\n  /* --- static utilities --- */\n  static GetSequencer(seqName) {\n    m_ValidateSeqName(seqName);\n    return OPSEQS.get(seqName);\n  }\n  static DeleteSequencer(seqName) {\n    const seq = _OpSequencer.GetSequencer(seqName);\n    seq.opsMap.clear();\n    seq.subs.forEach((subs) => subs.clear());\n    seq.ops.length = 0;\n    seq._disposed = true;\n    OPSEQS.delete(seqName);\n  }\n};\nvar class_op_seq_default = OpSequencer;\n\n// _ur/common/class-state-mgr.ts\nvar VM_STATE = {};\nvar GROUPS = /* @__PURE__ */ new Map();\nvar USED_PROPS = /* @__PURE__ */ new Map();\nvar StateMgr = class _StateMgr {\n  // queued side effects\n  /// CONSTRUCTOR /////////////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  constructor(groupName) {\n    __publicField(this, \"name\");\n    // the name of this state group\n    __publicField(this, \"init\");\n    // true if _initializeState has been called\n    __publicField(this, \"subs\");\n    __publicField(this, \"queue\");\n    // queued state changes\n    __publicField(this, \"taps\");\n    // queued state interceptor hooks\n    __publicField(this, \"effects\");\n    if (typeof groupName !== \"string\")\n      throw Error(\"groupName must be a string\");\n    groupName = groupName.trim().toUpperCase();\n    if (GROUPS.has(groupName)) {\n      console.warn(\n        `(not an error) '${groupName}' construction duplicate, returning existing instance`\n      );\n      return GROUPS.get(groupName);\n    }\n    this.name = groupName;\n    this.init = false;\n    this.subs = /* @__PURE__ */ new Set();\n    this.queue = [];\n    this.taps = [];\n    this.effects = [];\n    VM_STATE[this.name] = {};\n    this.state = this.state.bind(this);\n    this.sendState = this.sendState.bind(this);\n    this.subscribeState = this.subscribeState.bind(this);\n    this.unsubscribeState = this.unsubscribeState.bind(this);\n    this.queueEffect = this.queueEffect.bind(this);\n    this._initializeState = this._initializeState.bind(this);\n    this._setState = this._setState.bind(this);\n    this._insertStateEvent = this._insertStateEvent.bind(this);\n    this._interceptState = this._interceptState.bind(this);\n    this._isValidState = this._isValidState.bind(this);\n    this._mergeState = this._mergeState.bind(this);\n    this._notifySubs = this._notifySubs.bind(this);\n    this._enqueue = this._enqueue.bind(this);\n    this._dequeue = this._dequeue.bind(this);\n    this._doEffect = this._doEffect.bind(this);\n    GROUPS.set(this.name, this);\n  }\n  /// MAIN CLASS METHODS //////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** Return a COPY of the current clonedEvent */\n  state(key) {\n    const state = this._derefProps({ ...VM_STATE[this.name] });\n    if (typeof key === \"string\" && key.length > 0)\n      return state[key];\n    return state;\n  }\n  /** Handle a clonedEvent update from a subscribing module. The incoming\n   *  vmstateEvent is checked against the master state object to ensure it\n   *  contains valid keys. Any filter functions are allowed to mutate a copy of\n   *  the incoming state event.\n   *  @param {object} vmStateEvent - object with group-specific props\n   */\n  sendState(vmStateEvent, callback) {\n    if (this._isValidState(vmStateEvent)) {\n      const clonedEvent = this._cloneStateObject(vmStateEvent);\n      this.taps.forEach((tap) => tap(clonedEvent));\n      const action = { stateEvent: clonedEvent, callback };\n      this._enqueue(action);\n    } else\n      throw Error(\"SendState: invalid vmState update received, got:\");\n  }\n  /** Subscribe to state. The subscriber function looks like:\n   *  ( vmStateEvent, currentState ) => void\n   */\n  subscribeState(subFunc) {\n    if (typeof subFunc !== \"function\")\n      throw Error(\"subscriber must be function\");\n    if (this.subs.has(subFunc))\n      console.warn(\"duplicate subscriber function\");\n    this.subs.add(subFunc);\n  }\n  /** Unsubscribe state */\n  unsubscribeState(subFunc) {\n    if (!this.subs.delete(subFunc))\n      console.warn(\"function not subscribed for\", this.name);\n  }\n  /** When executing a side effect from a component, use this method to\n   *  hold it until after all state updates have completed, so the DOM\n   *  is stable\n   */\n  queueEffect(effectFunc) {\n    if (typeof effectFunc !== \"function\")\n      throw Error(\"effect must be a function\");\n    this.effects.push(effectFunc);\n    this._doEffect();\n  }\n  /// CLASS HELPER METHODS ////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** Set the state object directly. used to initialize the state from within\n   *  an appcore module. skips state validation because the VM_STATE entry\n   *  is an empty object\n   */\n  _initializeState(stateObj) {\n    if (this.init)\n      throw Error(`_initializeState: store '${this.name}' already initialized`);\n    Object.keys(stateObj).forEach((k) => {\n      if (k.toLowerCase() !== k)\n        throw Error(`_initializeState: props must be lowercase, not '${k}'`);\n      if (stateObj[k] === void 0)\n        throw Error(\n          `_initializeState: prop '${k}' value can't be undefined (use null instead)`\n        );\n    });\n    if (VM_STATE[this.name]) {\n      Object.keys(stateObj).forEach((k) => {\n        if (k === \"_group\")\n          return;\n        const assTo = USED_PROPS.get(k);\n        if (assTo !== void 0)\n          throw Error(`${k} already assigned to ${assTo}`);\n        USED_PROPS.set(k, this.name);\n      });\n      VM_STATE[this.name] = stateObj;\n      this.init = true;\n    } else\n      throw Error(`${this.name} does't exist in VM_STATE`);\n  }\n  /** In some cases, we want to update state but not trigger subscribers\n   *  related to it. Alias for _mergeState()\n   */\n  _setState(vmState) {\n    this._mergeState(vmState);\n  }\n  /** When SendState() is invoked, give the instance manager a change to\n   *  inspect the incoming state and do a side-effect and/or a filter.\n   *  They will run in order of interceptor registration\n   *  @param {function} tapFunc - receive stateEvent to mutate or act-on\n   */\n  _interceptState(tapFunc) {\n    if (typeof tapFunc !== \"function\")\n      throw Error(`'${tapFunc}' is not a function`);\n    this.taps.push(tapFunc);\n  }\n  /** Allow synthesis of a state event by adding to queue without\n   *  immediately executing it. For use by _interceptState only.\n   *  Creates an action { stateObj, callback }\n   */\n  _insertStateEvent(stateEvent, callback) {\n    this._enqueue({ stateEvent, callback });\n  }\n  /** Return true if the event object conforms to expectations (see below) */\n  _isValidState(stateObj) {\n    const curState = VM_STATE[this.name];\n    let keysOk = true;\n    Object.keys(stateObj).forEach((k) => {\n      const keyTest = keysOk && curState[k] !== void 0;\n      if (keyTest === false)\n        console.warn(`isValidState: '${k}' not a valid key`);\n      keysOk = keysOk && keyTest;\n    });\n    return keysOk;\n  }\n  /** Scan the object properties for arrays, and mutate with a new array.\n   *  In the case of an array containing references, the references will still\n   *  be the same but the array itself will be different\n   */\n  _derefProps(stateObj) {\n    Object.keys(stateObj).forEach((k) => {\n      if (Array.isArray(stateObj[k]))\n        stateObj[k] = [...stateObj[k]];\n    });\n    return stateObj;\n  }\n  /** Utility method to clone state event. It handles array cloning as well but\n   *  is otherwise a shallow clone\n   */\n  _cloneStateObject(stateObj) {\n    const clone = this._derefProps({ ...stateObj });\n    return clone;\n  }\n  /** Take a clonedEvent event object and update the VM_STATE entry with\n   *  its property values. This creates an entirely new state object\n   */\n  _mergeState(stateObj) {\n    if (!this._isValidState(stateObj))\n      return void 0;\n    const newState = this._derefProps({\n      ...VM_STATE[this.name],\n      ...stateObj\n    });\n    VM_STATE[this.name] = newState;\n    return newState;\n  }\n  /** Forward the event to everyone. The vmStateEvent object contains\n   *  properties that changed only, appending a 'stateGroup' identifier\n   *  that tells you who sent it. Sends a read-only copy.\n   */\n  _notifySubs(stateObj) {\n    setTimeout(() => {\n      const subs = [...this.subs.values()];\n      stateObj.stateGroup = this.name;\n      const currentState = this._derefProps({ ...VM_STATE[this.name] });\n      subs.forEach((sub) => sub(stateObj, currentState));\n    });\n  }\n  /** Placeholder queueing system that doesn't do much now.\n   *  An action is { vmStateEvent, callback }\n   */\n  _enqueue(action) {\n    const { stateEvent, callback } = action;\n    if (!this._isValidState(stateEvent)) {\n      console.warn(\"bad vmStateEvent\", stateEvent);\n      return;\n    }\n    if (callback && typeof callback !== \"function\") {\n      console.warn(\"call must be function, not\", typeof callback, callback);\n      return;\n    }\n    this.queue.push(action);\n    this._dequeue();\n  }\n  /** Placeholder dequeing system that doesn't do much now.\n   *  An action is { vmStateEvent, callback }\n   */\n  _dequeue() {\n    const callbacks = [];\n    let action = this.queue.shift();\n    while (action !== void 0) {\n      const { vmStateEvent, callback } = action;\n      this._mergeState(vmStateEvent);\n      this._notifySubs(vmStateEvent);\n      if (typeof callback === \"function\")\n        callbacks.push(callback);\n      action = this.queue.shift();\n    }\n    callbacks.forEach((f) => f());\n    this._doEffect();\n  }\n  /** execute effect functions that have been queued, generally if there\n   *  are no pending state changes\n   */\n  _doEffect() {\n    if (this.queue.length > 0)\n      return;\n    setTimeout(() => {\n      let effect = this.effects.shift();\n      while (effect !== void 0) {\n        effect();\n        effect = this.effects.shift();\n      }\n    });\n  }\n  /// STATIC METHODS //////////////////////////////////////////////////////////\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** Return a state manager instance if it exists, undefined if not. Throws\n   *  errors if there are issues with the name */\n  static GetStateManager(groupName) {\n    if (typeof groupName !== \"string\")\n      throw Error(`${groupName} is not a string`);\n    const bucket = groupName.trim().toUpperCase();\n    if (bucket !== groupName)\n      throw Error(`groupNames should be all uppercase, not ${bucket}`);\n    return GROUPS[bucket];\n  }\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** return a locked copy of the state of a particular named state group.\n   *  Unlike GetStateManager, this returns just the data object.\n   */\n  static GetStateData(groupName) {\n    if (typeof groupName !== \"string\")\n      throw Error(`${groupName} is not a string`);\n    const bucket = groupName.trim().toUpperCase();\n    if (bucket !== groupName)\n      throw Error(`groupNames should be all uppercase, not ${bucket}`);\n    const state = VM_STATE[bucket];\n    if (!state)\n      throw Error(`stateGroup ${bucket} is not defined`);\n    const readOnlyState = { ...state };\n    for (const prop of Object.keys(readOnlyState)) {\n      Object.defineProperty(readOnlyState, prop, {\n        writable: false\n      });\n    }\n    return readOnlyState;\n  }\n  /// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  /** return a Stage Manager instance. This just hides the new operator that\n   *  purposefully always returns an instance of an existing group if it\n   *  already exists\n   */\n  static GetInstance(groupName) {\n    return new _StateMgr(groupName);\n  }\n};\nvar class_state_mgr_default = StateMgr;\n\n// _ur/browser-client/@client.ts\nvar { makeStyleFormatter } = import_util_prompts.default;\nvar PR = makeStyleFormatter(\"UR\", \"TagCyan\");\nvar CLASS = {\n  OpSequencer: class_op_seq_default,\n  StateMgr: class_state_mgr_default\n};\nfunction ClientTest() {\n  console.log(...PR(\"System Integration of new URSYS module successful!\"));\n}\n//# sourceMappingURL=client-cjs.js.map\n  })();\n});"]}